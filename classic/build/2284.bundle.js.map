{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/application/lib/layoutrestorer.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/application/lib/mimerenderers.js"],"names":["ILayoutRestorer","Token","KEY","LayoutRestorer","options","this","_firstDone","_promisesDone","_promises","_restored","PromiseDelegate","_trackers","Set","_widgets","Map","_connector","connector","_first","first","_registry","registry","then","Promise","all","clear","resolve","promise","widget","name","Private","nameProperty","set","disposed","connect","_onWidgetDisposed","blank","fresh","mainArea","leftArea","rightArea","layout","fetch","data","restored","main","left","right","_rehydrateMainArea","_rehydrateSideArea","error","tracker","warning","console","warn","reject","namespace","has","args","command","when","add","widgetAdded","_","widgetName","widgetUpdated","restore","JSONExt","concat","catch","push","dehydrated","_dehydrateMainArea","_dehydrateSideArea","save","area","serializeMain","deserializeMain","collapsed","currentWidget","current","get","widgets","map","filter","_a","internal","Array","isArray","delete","serializeArea","type","currentIndex","orientation","sizes","children","deserializeArea","names","hydrated","length","child","AttachedProperty","create","owner","dock","IMimeDocumentTracker","createRendermimePlugins","extensions","plugins","WidgetTracker","forEach","mod","default","hasOwnProperty","item","id","requires","IRenderMimeRegistry","ITranslator","autoStart","activate","app","rendermime","translator","undefined","rank","addFactory","rendererFactory","documentWidgetFactoryOptions","docRegistry","fileTypes","ft","icon","Object","assign","LabIcon","addFileType","option","toolbarFactory","w","content","renderer","factory","MimeDocumentFactory","renderTimeout","dataType","modelName","primaryFileType","getFileType","defaultFor","defaultRendered","addWidgetFactory","widgetCreated","sender","factoryNameProperty","context","pathChanged","createRendermimePlugin","optional","provides","restorer","path"],"mappings":"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","file":"2284.bundle.js","sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { JSONExt, PromiseDelegate, Token } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\n/**\n * The layout restorer token.\n */\nexport const ILayoutRestorer = new Token('@jupyterlab/application:ILayoutRestorer');\n/**\n * The data connector key for restorer data.\n */\nconst KEY = 'layout-restorer:data';\n/**\n * The default implementation of a layout restorer.\n *\n * #### Notes\n * The lifecycle for state restoration is subtle. The sequence of events is:\n *\n * 1. The layout restorer plugin is instantiated and makes a `fetch` call to\n *    the data connector that stores the layout restoration data. The `fetch`\n *    call returns a promise that resolves in step 6, below.\n *\n * 2. Other plugins that care about state restoration require the layout\n *    restorer as a dependency.\n *\n * 3. As each load-time plugin initializes (which happens before the front-end\n *    application has `started`), it instructs the layout restorer whether\n *    the restorer ought to `restore` its widgets by passing in its widget\n *    tracker.\n *    Alternatively, a plugin that does not require its own widget tracker\n *    (because perhaps it only creates a single widget, like a command palette),\n *    can simply `add` its widget along with a persistent unique name to the\n *    layout restorer so that its layout state can be restored when the lab\n *    application restores.\n *\n * 4. After all the load-time plugins have finished initializing, the front-end\n *    application `started` promise will resolve. This is the `first`\n *    promise that the layout restorer waits for. By this point, all of the\n *    plugins that care about restoration will have instructed the layout\n *    restorer to `restore` their widget trackers.\n *\n * 5. The layout restorer will then instruct each plugin's widget tracker\n *    to restore its state and reinstantiate whichever widgets it wants. The\n *    tracker returns a promise to the layout restorer that resolves when it\n *    has completed restoring the tracked widgets it cares about.\n *\n * 6. As each widget tracker finishes restoring the widget instances it cares\n *    about, it resolves the promise that was returned to the layout restorer\n *    (in step 5). After all of the promises that the restorer is awaiting have\n *    settled, the restorer then resolves the outstanding `fetch` promise\n *    (from step 1) and hands off a layout state object to the application\n *    shell's `restoreLayout` method for restoration.\n *\n * 7. Once the application shell has finished restoring the layout, the\n *    JupyterLab application's `restored` promise is resolved.\n *\n * Of particular note are steps 5 and 6: since data restoration of plugins\n * is accomplished by executing commands, the command that is used to restore\n * the data of each plugin must return a promise that only resolves when the\n * widget has been created and added to the plugin's widget tracker.\n */\nexport class LayoutRestorer {\n    /**\n     * Create a layout restorer.\n     */\n    constructor(options) {\n        this._firstDone = false;\n        this._promisesDone = false;\n        this._promises = [];\n        this._restored = new PromiseDelegate();\n        this._trackers = new Set();\n        this._widgets = new Map();\n        this._connector = options.connector;\n        this._first = options.first;\n        this._registry = options.registry;\n        void this._first\n            .then(() => {\n            this._firstDone = true;\n        })\n            .then(() => Promise.all(this._promises))\n            .then(() => {\n            this._promisesDone = true;\n            // Release the tracker set.\n            this._trackers.clear();\n        })\n            .then(() => {\n            this._restored.resolve(void 0);\n        });\n    }\n    /**\n     * A promise resolved when the layout restorer is ready to receive signals.\n     */\n    get restored() {\n        return this._restored.promise;\n    }\n    /**\n     * Add a widget to be tracked by the layout restorer.\n     */\n    add(widget, name) {\n        Private.nameProperty.set(widget, name);\n        this._widgets.set(name, widget);\n        widget.disposed.connect(this._onWidgetDisposed, this);\n    }\n    /**\n     * Fetch the layout state for the application.\n     *\n     * #### Notes\n     * Fetching the layout relies on all widget restoration to be complete, so\n     * calls to `fetch` are guaranteed to return after restoration is complete.\n     */\n    async fetch() {\n        const blank = {\n            fresh: true,\n            mainArea: null,\n            leftArea: null,\n            rightArea: null\n        };\n        const layout = this._connector.fetch(KEY);\n        try {\n            const [data] = await Promise.all([layout, this.restored]);\n            if (!data) {\n                return blank;\n            }\n            const { main, left, right } = data;\n            // If any data exists, then this is not a fresh session.\n            const fresh = false;\n            // Rehydrate main area.\n            const mainArea = this._rehydrateMainArea(main);\n            // Rehydrate left area.\n            const leftArea = this._rehydrateSideArea(left);\n            // Rehydrate right area.\n            const rightArea = this._rehydrateSideArea(right);\n            return { fresh, mainArea, leftArea, rightArea };\n        }\n        catch (error) {\n            return blank;\n        }\n    }\n    /**\n     * Restore the widgets of a particular widget tracker.\n     *\n     * @param tracker - The widget tracker whose widgets will be restored.\n     *\n     * @param options - The restoration options.\n     */\n    restore(tracker, options) {\n        const warning = 'restore() can only be called before `first` has resolved.';\n        if (this._firstDone) {\n            console.warn(warning);\n            return Promise.reject(warning);\n        }\n        const { namespace } = tracker;\n        if (this._trackers.has(namespace)) {\n            const warning = `A tracker namespaced ${namespace} was already restored.`;\n            console.warn(warning);\n            return Promise.reject(warning);\n        }\n        const { args, command, name, when } = options;\n        // Add the tracker to the private trackers collection.\n        this._trackers.add(namespace);\n        // Whenever a new widget is added to the tracker, record its name.\n        tracker.widgetAdded.connect((_, widget) => {\n            const widgetName = name(widget);\n            if (widgetName) {\n                this.add(widget, `${namespace}:${widgetName}`);\n            }\n        }, this);\n        // Whenever a widget is updated, get its new name.\n        tracker.widgetUpdated.connect((_, widget) => {\n            const widgetName = name(widget);\n            if (widgetName) {\n                const name = `${namespace}:${widgetName}`;\n                Private.nameProperty.set(widget, name);\n                this._widgets.set(name, widget);\n            }\n        });\n        const first = this._first;\n        const promise = tracker\n            .restore({\n            args: args || (() => JSONExt.emptyObject),\n            command,\n            connector: this._connector,\n            name,\n            registry: this._registry,\n            when: when ? [first].concat(when) : first\n        })\n            .catch(error => {\n            console.error(error);\n        });\n        this._promises.push(promise);\n        return promise;\n    }\n    /**\n     * Save the layout state for the application.\n     */\n    save(data) {\n        // If there are promises that are unresolved, bail.\n        if (!this._promisesDone) {\n            const warning = 'save() was called prematurely.';\n            console.warn(warning);\n            return Promise.reject(warning);\n        }\n        const dehydrated = {};\n        dehydrated.main = this._dehydrateMainArea(data.mainArea);\n        dehydrated.left = this._dehydrateSideArea(data.leftArea);\n        dehydrated.right = this._dehydrateSideArea(data.rightArea);\n        return this._connector.save(KEY, dehydrated);\n    }\n    /**\n     * Dehydrate a main area description into a serializable object.\n     */\n    _dehydrateMainArea(area) {\n        if (!area) {\n            return null;\n        }\n        return Private.serializeMain(area);\n    }\n    /**\n     * Reydrate a serialized main area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateMainArea(area) {\n        if (!area) {\n            return null;\n        }\n        return Private.deserializeMain(area, this._widgets);\n    }\n    /**\n     * Dehydrate a side area description into a serializable object.\n     */\n    _dehydrateSideArea(area) {\n        if (!area) {\n            return null;\n        }\n        const dehydrated = { collapsed: area.collapsed };\n        if (area.currentWidget) {\n            const current = Private.nameProperty.get(area.currentWidget);\n            if (current) {\n                dehydrated.current = current;\n            }\n        }\n        if (area.widgets) {\n            dehydrated.widgets = area.widgets\n                .map(widget => Private.nameProperty.get(widget))\n                .filter(name => !!name);\n        }\n        return dehydrated;\n    }\n    /**\n     * Reydrate a serialized side area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateSideArea(area) {\n        var _a;\n        if (!area) {\n            return { collapsed: true, currentWidget: null, widgets: null };\n        }\n        const internal = this._widgets;\n        const collapsed = (_a = area.collapsed) !== null && _a !== void 0 ? _a : false;\n        const currentWidget = area.current && internal.has(`${area.current}`)\n            ? internal.get(`${area.current}`)\n            : null;\n        const widgets = !Array.isArray(area.widgets)\n            ? null\n            : area.widgets\n                .map(name => internal.has(`${name}`) ? internal.get(`${name}`) : null)\n                .filter(widget => !!widget);\n        return {\n            collapsed,\n            currentWidget: currentWidget,\n            widgets: widgets\n        };\n    }\n    /**\n     * Handle a widget disposal.\n     */\n    _onWidgetDisposed(widget) {\n        const name = Private.nameProperty.get(widget);\n        this._widgets.delete(name);\n    }\n}\n/*\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for a widget's ID in the serialized restore data.\n     */\n    Private.nameProperty = new AttachedProperty({\n        name: 'name',\n        create: owner => ''\n    });\n    /**\n     * Serialize individual areas within the main area.\n     */\n    function serializeArea(area) {\n        if (!area || !area.type) {\n            return null;\n        }\n        if (area.type === 'tab-area') {\n            return {\n                type: 'tab-area',\n                currentIndex: area.currentIndex,\n                widgets: area.widgets\n                    .map(widget => Private.nameProperty.get(widget))\n                    .filter(name => !!name)\n            };\n        }\n        return {\n            type: 'split-area',\n            orientation: area.orientation,\n            sizes: area.sizes,\n            children: area.children\n                .map(serializeArea)\n                .filter(area => !!area)\n        };\n    }\n    /**\n     * Return a dehydrated, serializable version of the main dock panel.\n     */\n    function serializeMain(area) {\n        const dehydrated = {\n            dock: (area && area.dock && serializeArea(area.dock.main)) || null\n        };\n        if (area) {\n            if (area.currentWidget) {\n                const current = Private.nameProperty.get(area.currentWidget);\n                if (current) {\n                    dehydrated.current = current;\n                }\n            }\n        }\n        return dehydrated;\n    }\n    Private.serializeMain = serializeMain;\n    /**\n     * Deserialize individual areas within the main area.\n     *\n     * #### Notes\n     * Because this data comes from a potentially unreliable foreign source, it is\n     * typed as a `JSONObject`; but the actual expected type is:\n     * `ITabArea | ISplitArea`.\n     *\n     * For fault tolerance, types are manually checked in deserialization.\n     */\n    function deserializeArea(area, names) {\n        if (!area) {\n            return null;\n        }\n        // Because this data is saved to a foreign data source, its type safety is\n        // not guaranteed when it is retrieved, so exhaustive checks are necessary.\n        const type = area.type || 'unknown';\n        if (type === 'unknown' || (type !== 'tab-area' && type !== 'split-area')) {\n            console.warn(`Attempted to deserialize unknown type: ${type}`);\n            return null;\n        }\n        if (type === 'tab-area') {\n            const { currentIndex, widgets } = area;\n            const hydrated = {\n                type: 'tab-area',\n                currentIndex: currentIndex || 0,\n                widgets: (widgets &&\n                    widgets\n                        .map(widget => names.get(widget))\n                        .filter(widget => !!widget)) ||\n                    []\n            };\n            // Make sure the current index is within bounds.\n            if (hydrated.currentIndex > hydrated.widgets.length - 1) {\n                hydrated.currentIndex = 0;\n            }\n            return hydrated;\n        }\n        const { orientation, sizes, children } = area;\n        const hydrated = {\n            type: 'split-area',\n            orientation: orientation,\n            sizes: sizes || [],\n            children: (children &&\n                children\n                    .map(child => deserializeArea(child, names))\n                    .filter(widget => !!widget)) ||\n                []\n        };\n        return hydrated;\n    }\n    /**\n     * Return the hydrated version of the main dock panel, ready to restore.\n     *\n     * #### Notes\n     * Because this data comes from a potentially unreliable foreign source, it is\n     * typed as a `JSONObject`; but the actual expected type is: `IMainArea`.\n     *\n     * For fault tolerance, types are manually checked in deserialization.\n     */\n    function deserializeMain(area, names) {\n        if (!area) {\n            return null;\n        }\n        const name = area.current || null;\n        const dock = area.dock || null;\n        return {\n            currentWidget: (name && names.has(name) && names.get(name)) || null,\n            dock: dock ? { main: deserializeArea(dock, names) } : null\n        };\n    }\n    Private.deserializeMain = deserializeMain;\n})(Private || (Private = {}));\n//# sourceMappingURL=layoutrestorer.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { WidgetTracker } from '@jupyterlab/apputils';\nimport { MimeDocumentFactory } from '@jupyterlab/docregistry';\nimport { IRenderMimeRegistry } from '@jupyterlab/rendermime';\nimport { LabIcon } from '@jupyterlab/ui-components';\nimport { Token } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\nimport { ILayoutRestorer } from './layoutrestorer';\nimport { ITranslator } from '@jupyterlab/translation';\n/**\n * The mime document tracker token.\n */\nexport const IMimeDocumentTracker = new Token('@jupyterlab/application:IMimeDocumentTracker');\n/**\n * Create rendermime plugins for rendermime extension modules.\n */\nexport function createRendermimePlugins(extensions) {\n    const plugins = [];\n    const namespace = 'application-mimedocuments';\n    const tracker = new WidgetTracker({ namespace });\n    extensions.forEach(mod => {\n        let data = mod.default;\n        // Handle CommonJS exports.\n        if (!mod.hasOwnProperty('__esModule')) {\n            data = mod;\n        }\n        if (!Array.isArray(data)) {\n            data = [data];\n        }\n        data.forEach(item => {\n            plugins.push(createRendermimePlugin(tracker, item));\n        });\n    });\n    // Also add a meta-plugin handling state restoration\n    // and exposing the mime document widget tracker.\n    plugins.push({\n        id: '@jupyterlab/application:mimedocument',\n        optional: [ILayoutRestorer],\n        provides: IMimeDocumentTracker,\n        autoStart: true,\n        activate: (app, restorer) => {\n            if (restorer) {\n                void restorer.restore(tracker, {\n                    command: 'docmanager:open',\n                    args: widget => ({\n                        path: widget.context.path,\n                        factory: Private.factoryNameProperty.get(widget)\n                    }),\n                    name: widget => `${widget.context.path}:${Private.factoryNameProperty.get(widget)}`\n                });\n            }\n            return tracker;\n        }\n    });\n    return plugins;\n}\n/**\n * Create rendermime plugins for rendermime extension modules.\n */\nexport function createRendermimePlugin(tracker, item) {\n    return {\n        id: item.id,\n        requires: [IRenderMimeRegistry, ITranslator],\n        autoStart: true,\n        activate: (app, rendermime, translator) => {\n            // Add the mime renderer.\n            if (item.rank !== undefined) {\n                rendermime.addFactory(item.rendererFactory, item.rank);\n            }\n            else {\n                rendermime.addFactory(item.rendererFactory);\n            }\n            // Handle the widget factory.\n            if (!item.documentWidgetFactoryOptions) {\n                return;\n            }\n            const registry = app.docRegistry;\n            let options = [];\n            if (Array.isArray(item.documentWidgetFactoryOptions)) {\n                options = item.documentWidgetFactoryOptions;\n            }\n            else {\n                options = [\n                    item.documentWidgetFactoryOptions\n                ];\n            }\n            if (item.fileTypes) {\n                item.fileTypes.forEach(ft => {\n                    if (ft.icon) {\n                        // upconvert the contents of the icon field to a proper LabIcon\n                        ft = Object.assign(Object.assign({}, ft), { icon: LabIcon.resolve({ icon: ft.icon }) });\n                    }\n                    app.docRegistry.addFileType(ft);\n                });\n            }\n            options.forEach(option => {\n                const toolbarFactory = option.toolbarFactory\n                    ? (w) => option.toolbarFactory(w.content.renderer)\n                    : undefined;\n                const factory = new MimeDocumentFactory({\n                    renderTimeout: item.renderTimeout,\n                    dataType: item.dataType,\n                    rendermime,\n                    modelName: option.modelName,\n                    name: option.name,\n                    primaryFileType: registry.getFileType(option.primaryFileType),\n                    fileTypes: option.fileTypes,\n                    defaultFor: option.defaultFor,\n                    defaultRendered: option.defaultRendered,\n                    toolbarFactory,\n                    translator,\n                    factory: item.rendererFactory\n                });\n                registry.addWidgetFactory(factory);\n                factory.widgetCreated.connect((sender, widget) => {\n                    Private.factoryNameProperty.set(widget, factory.name);\n                    // Notify the widget tracker if restore data needs to update.\n                    widget.context.pathChanged.connect(() => {\n                        void tracker.save(widget);\n                    });\n                    void tracker.add(widget);\n                });\n            });\n        }\n    };\n}\n/**\n * Private namespace for the module.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for keeping the factory name\n     * that was used to create a mimedocument.\n     */\n    Private.factoryNameProperty = new AttachedProperty({\n        name: 'factoryName',\n        create: () => undefined\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=mimerenderers.js.map"],"sourceRoot":""}
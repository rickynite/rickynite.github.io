{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/searchoverlay.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/searchinstance.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/searchproviderregistry.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/providers/codemirrorsearchprovider.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/providers/genericsearchprovider.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch/lib/providers/notebooksearchprovider.js"],"names":["OVERLAY_ROW_CLASS","INPUT_BUTTON_CLASS_OFF","INPUT_BUTTON_CLASS_ON","UP_DOWN_BUTTON_CLASS","REPLACE_BUTTON_CLASS","REPLACE_BUTTON_WRAPPER_CLASS","BUTTON_CONTENT_CLASS","BUTTON_WRAPPER_CLASS","SearchEntry","props","super","this","translator","nullTranslator","_trans","load","searchInputRef","_a","current","select","forceFocus","focusInput","caseButtonToggleClass","classes","caseSensitive","regexButtonToggleClass","useRegex","wrapperClass","inputFocused","className","placeholder","searchText","undefined","__","value","onChange","e","onKeyDown","onKeydown","tabIndex","onFocus","onInputFocus","onBlur","onInputBlur","ref","onClick","onCaseSensitiveToggled","caseSensitiveIcon","tag","onRegexToggled","regexIcon","ReplaceEntry","replaceInputRef","replaceText","onReplaceKeydown","onReplaceCurrent","onReplaceAll","UpDownButtons","onHighlightPrevious","caretUpEmptyThinIcon","onHightlightNext","caretDownEmptyThinIcon","SearchIndices","totalMatches","currentIndex","FilterToggle","enabled","toggleEnabled","ellipsesIcon","height","width","FilterSelection","canToggleOutput","type","disabled","checked","searchOutput","toggleOutput","SearchOverlay","_debouncedStartSearch","Debouncer","_executeSearch","state","overlayState","replaceEntryRef","_toggleSearchOutput","bind","event","target","setState","invoke","keyCode","preventDefault","stopPropagation","shiftKey","_onClose","goForward","filterChanged","query","input","Private","parseQuery","errorMessage","message","regexEqual","onStartQuery","filters","onEndSearch","dispose","replaceEntryShown","searchInputFocused","prevState","Object","assign","output","filtersOpen","showReplace","isReadOnly","showFilter","hasOutputs","filterToggle","_toggleFiltersOpen","filter","key","icon","caretDownIcon","caretRightIcon","_onReplaceToggled","react","elementPosition","_onSearchKeydown","_onSearchChange","_onSearchInputFocus","_onSearchInputBlur","closeIcon","_onReplaceKeydown","_onReplaceChange","hidden","length","queryString","regex","flag","queryText","replace","ret","RegExp","test","a","b","source","global","ignoreCase","multiline","SearchInstance","widget","searchProvider","_displayState","replaceInputFocused","_displayUpdateSignal","Signal","_isDisposed","_disposed","_widget","_activeProvider","initialQuery","getInitialQuery","_searchWidget","options","widgetChanged","ReactWidget","UseSignal","signal","initialArgs","_","args","addClass","createSearchOverlay","_onCaseSensitiveToggled","_onRegexToggled","_highlightNext","_highlightPrevious","_startQuery","_replaceCurrent","_replaceAll","disposed","connect","activate","MainAreaWidget","node","style","top","toolbar","clientHeight","_displaySearchWidget","emit","matches","currentMatchIndex","_updateDisplay","endQuery","startQuery","updateIndices","changed","newText","replaceCurrentMatch","replaceAllMatches","isDisposed","endSearch","isAttached","Widget","highlightNext","highlightPrevious","SearchProviderRegistry","_changed","_providerMap","Map","provider","set","DisposableDelegate","delete","_findMatchingProvider","providerMap","P","values","canSearchOn","ISearchProviderRegistry","Token","CodeMirrorSearchProvider","isSubProvider","_matchState","searchTarget","selection","content","editor","doc","getSelection","search","Error","_cm","_refreshOverlay","refreshOverlay","_query","_onDocChanged","_setInitialMatches","_parseMatchesFromState","cursorMatch","_findNext","match","from","line","ch","_currentMatch","removeOverlay","_overlay","getCursor","to","setSelection","start","_toEditorPos","end","focus","replaceOccurred","_currentMatchIsSelected","cursor","getSearchCursor","findNext","Promise","resolve","operation","domain","FileEditor","CodeMirrorEditor","index","changeObj","_b","text","removed","_getSearchOverlay","addOverlay","firstLine","lastLine","getRange","split","forEach","lineNumber","lastIndex","exec","col","matchObj","column","fragment","token","stream","currentPos","pos","lineText","string","lineOracle","matchLength","substr","eol","skipToEnd","reverse","cursorToGet","lastPosition","position","find","setCursorPosition","scroll","startOrEnd","fromPos","toPos","selRange","scrollIntoView","keys","reduce","result","lineKey","parseInt","lineMatches","posKey","push","posIn","currentSelection","currentSelectionLength","selectionIsOneLine","SearchState","FOUND_CLASSES","SELECTED_CLASSES","GenericSearchProvider","_matches","_mutationObserver","MutationObserver","_onWidgetChanged","that","disconnect","walker","document","createTreeWalker","NodeFilter","SHOW_TEXT","acceptNode","parentElement","nodeName","UNSUPPORTED_ELEMENTS","FILTER_REJECT","textContent","FILTER_ACCEPT","nodes","originalNodes","nextNode","cloneNode","flags","indexOf","nodeIndex","q","subsections","originalNode","originalLength","lastNodeAdded","newMatches","idx","spannedNode","createElement","classList","add","innerText","slice","parentNode","prepend","append","insertBefore","endText","splitText","unshift","matchesIndex","indexInOriginal","spanElement","observe","attributes","characterData","childList","subtree","replaceWith","remove","nextIndex","el","boundingClientRect","getBoundingClientRect","bottom","window","innerHeight","documentElement","left","right","innerWidth","clientWidth","elementInViewport","map","m","mutations","observer","BASE","HEAD","LINK","META","STYLE","TITLE","BODY","AREA","AUDIO","IMG","MAP","TRACK","VIDEO","APPLET","EMBED","IFRAME","NOEMBED","OBJECT","PARAM","PICTURE","SOURCE","CANVAS","NOSCRIPT","SCRIPT","SVG","NotebookSearchProvider","_searchProviders","_unRenderedMarkdownCells","_cellsWithMatches","activeCell","_searchTarget","cells","widgets","_filters","entries","hide","indexTotal","allMatches","cell","cmEditor","cmSearchProvider","cellShouldReRender","MarkdownCell","rendered","inputHidden","matchesFromCell","startQueryCodeMirror","_onSearchProviderChanged","concat","CodeCell","outputProivder","matchesFromOutput","outputArea","show","_stepNext","_updatedCurrentProvider","_refreshCurrentCellEditor","_refreshCellsEditorsInBackground","n","i","refreshNextNCells","stop","refresh","setTimeout","queriesEnded","model","_currentProvider","all","activeCellIndex","searchEnded","mode","currentMatch","NotebookPanel","_getMatchesFromCells","currentProviderIndex","ArrayExt","nextProviderIndex","currentSearchPair","steps","providerIndex","numProviders","nextSearchPair","newPosCM","newPos","notebook","cellMatches","cm"],"mappings":"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","file":"131.bundle.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ReactWidget, UseSignal } from '@jupyterlab/apputils';\nimport { caretDownIcon, caretDownEmptyThinIcon, caretRightIcon, caretUpEmptyThinIcon, caseSensitiveIcon, classes, closeIcon, ellipsesIcon, regexIcon } from '@jupyterlab/ui-components';\nimport { Debouncer } from '@lumino/polling';\nimport * as React from 'react';\nimport { nullTranslator } from '@jupyterlab/translation';\nconst OVERLAY_CLASS = 'jp-DocumentSearch-overlay';\nconst OVERLAY_ROW_CLASS = 'jp-DocumentSearch-overlay-row';\nconst INPUT_CLASS = 'jp-DocumentSearch-input';\nconst INPUT_WRAPPER_CLASS = 'jp-DocumentSearch-input-wrapper';\nconst INPUT_BUTTON_CLASS_OFF = 'jp-DocumentSearch-input-button-off';\nconst INPUT_BUTTON_CLASS_ON = 'jp-DocumentSearch-input-button-on';\nconst INDEX_COUNTER_CLASS = 'jp-DocumentSearch-index-counter';\nconst UP_DOWN_BUTTON_WRAPPER_CLASS = 'jp-DocumentSearch-up-down-wrapper';\nconst UP_DOWN_BUTTON_CLASS = 'jp-DocumentSearch-up-down-button';\nconst ELLIPSES_BUTTON_CLASS = 'jp-DocumentSearch-ellipses-button';\nconst ELLIPSES_BUTTON_ENABLED_CLASS = 'jp-DocumentSearch-ellipses-button-enabled';\nconst REGEX_ERROR_CLASS = 'jp-DocumentSearch-regex-error';\nconst SEARCH_OPTIONS_CLASS = 'jp-DocumentSearch-search-options';\nconst SEARCH_OPTIONS_DISABLED_CLASS = 'jp-DocumentSearch-search-options-disabled';\nconst REPLACE_ENTRY_CLASS = 'jp-DocumentSearch-replace-entry';\nconst REPLACE_BUTTON_CLASS = 'jp-DocumentSearch-replace-button';\nconst REPLACE_BUTTON_WRAPPER_CLASS = 'jp-DocumentSearch-replace-button-wrapper';\nconst REPLACE_WRAPPER_CLASS = 'jp-DocumentSearch-replace-wrapper-class';\nconst REPLACE_TOGGLE_CLASS = 'jp-DocumentSearch-replace-toggle';\nconst FOCUSED_INPUT = 'jp-DocumentSearch-focused-input';\nconst TOGGLE_WRAPPER = 'jp-DocumentSearch-toggle-wrapper';\nconst TOGGLE_PLACEHOLDER = 'jp-DocumentSearch-toggle-placeholder';\nconst BUTTON_CONTENT_CLASS = 'jp-DocumentSearch-button-content';\nconst BUTTON_WRAPPER_CLASS = 'jp-DocumentSearch-button-wrapper';\nconst SPACER_CLASS = 'jp-DocumentSearch-spacer';\nclass SearchEntry extends React.Component {\n    constructor(props) {\n        super(props);\n        this.translator = props.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        this.searchInputRef = React.createRef();\n    }\n    /**\n     * Focus the input.\n     */\n    focusInput() {\n        var _a;\n        // Select (and focus) any text already present.\n        // This makes typing in the box starts a new query (the common case),\n        // while arrow keys can be used to move cursor in preparation for\n        // modifying previous query.\n        (_a = this.searchInputRef.current) === null || _a === void 0 ? void 0 : _a.select();\n    }\n    componentDidUpdate() {\n        if (this.props.forceFocus) {\n            this.focusInput();\n        }\n    }\n    render() {\n        const caseButtonToggleClass = classes(this.props.caseSensitive ? INPUT_BUTTON_CLASS_ON : INPUT_BUTTON_CLASS_OFF, BUTTON_CONTENT_CLASS);\n        const regexButtonToggleClass = classes(this.props.useRegex ? INPUT_BUTTON_CLASS_ON : INPUT_BUTTON_CLASS_OFF, BUTTON_CONTENT_CLASS);\n        const wrapperClass = `${INPUT_WRAPPER_CLASS} ${this.props.inputFocused ? FOCUSED_INPUT : ''}`;\n        return (React.createElement(\"div\", { className: wrapperClass },\n            React.createElement(\"input\", { placeholder: this.props.searchText ? undefined : this._trans.__('Find'), className: INPUT_CLASS, value: this.props.searchText, onChange: e => this.props.onChange(e), onKeyDown: e => this.props.onKeydown(e), tabIndex: 2, onFocus: e => this.props.onInputFocus(), onBlur: e => this.props.onInputBlur(), ref: this.searchInputRef }),\n            React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => this.props.onCaseSensitiveToggled(), tabIndex: 4 },\n                React.createElement(caseSensitiveIcon.react, { className: caseButtonToggleClass, tag: \"span\" })),\n            React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => this.props.onRegexToggled(), tabIndex: 5 },\n                React.createElement(regexIcon.react, { className: regexButtonToggleClass, tag: \"span\" }))));\n    }\n}\nclass ReplaceEntry extends React.Component {\n    constructor(props) {\n        super(props);\n        this._trans = (props.translator || nullTranslator).load('jupyterlab');\n        this.replaceInputRef = React.createRef();\n    }\n    render() {\n        return (React.createElement(\"div\", { className: REPLACE_WRAPPER_CLASS },\n            React.createElement(\"input\", { placeholder: this.props.replaceText ? undefined : this._trans.__('Replace'), className: REPLACE_ENTRY_CLASS, value: this.props.replaceText, onKeyDown: e => this.props.onReplaceKeydown(e), onChange: e => this.props.onChange(e), tabIndex: 3, ref: this.replaceInputRef }),\n            React.createElement(\"button\", { className: REPLACE_BUTTON_WRAPPER_CLASS, onClick: () => this.props.onReplaceCurrent(), tabIndex: 10 },\n                React.createElement(\"span\", { className: `${REPLACE_BUTTON_CLASS} ${BUTTON_CONTENT_CLASS}`, tabIndex: -1 }, this._trans.__('Replace'))),\n            React.createElement(\"button\", { className: REPLACE_BUTTON_WRAPPER_CLASS, tabIndex: 11, onClick: () => this.props.onReplaceAll() },\n                React.createElement(\"span\", { className: `${REPLACE_BUTTON_CLASS} ${BUTTON_CONTENT_CLASS}`, tabIndex: -1 }, this._trans.__('Replace All')))));\n    }\n}\nfunction UpDownButtons(props) {\n    return (React.createElement(\"div\", { className: UP_DOWN_BUTTON_WRAPPER_CLASS },\n        React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => props.onHighlightPrevious(), tabIndex: 6 },\n            React.createElement(caretUpEmptyThinIcon.react, { className: classes(UP_DOWN_BUTTON_CLASS, BUTTON_CONTENT_CLASS), tag: \"span\" })),\n        React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => props.onHightlightNext(), tabIndex: 7 },\n            React.createElement(caretDownEmptyThinIcon.react, { className: classes(UP_DOWN_BUTTON_CLASS, BUTTON_CONTENT_CLASS), tag: \"span\" }))));\n}\nfunction SearchIndices(props) {\n    return (React.createElement(\"div\", { className: INDEX_COUNTER_CLASS }, props.totalMatches === 0\n        ? '-/-'\n        : `${props.currentIndex === null ? '-' : props.currentIndex + 1}/${props.totalMatches}`));\n}\nclass FilterToggle extends React.Component {\n    render() {\n        let className = `${ELLIPSES_BUTTON_CLASS} ${BUTTON_CONTENT_CLASS}`;\n        if (this.props.enabled) {\n            className = `${className} ${ELLIPSES_BUTTON_ENABLED_CLASS}`;\n        }\n        return (React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => this.props.toggleEnabled(), tabIndex: 8 },\n            React.createElement(ellipsesIcon.react, { className: className, tag: \"span\", height: \"20px\", width: \"20px\" })));\n    }\n}\nclass FilterSelection extends React.Component {\n    render() {\n        return (React.createElement(\"label\", { className: SEARCH_OPTIONS_CLASS },\n            React.createElement(\"span\", { className: this.props.canToggleOutput ? '' : SEARCH_OPTIONS_DISABLED_CLASS }, \"Search Cell Outputs\"),\n            React.createElement(\"input\", { type: \"checkbox\", disabled: !this.props.canToggleOutput, checked: this.props.searchOutput, onChange: this.props.toggleOutput })));\n    }\n}\nclass SearchOverlay extends React.Component {\n    constructor(props) {\n        super(props);\n        this._debouncedStartSearch = new Debouncer(() => {\n            this._executeSearch(true, this.state.searchText);\n        }, 500);\n        this.translator = props.translator || nullTranslator;\n        this.state = props.overlayState;\n        this.replaceEntryRef = React.createRef();\n        this._toggleSearchOutput = this._toggleSearchOutput.bind(this);\n    }\n    componentDidMount() {\n        if (this.state.searchText) {\n            this._executeSearch(true, this.state.searchText);\n        }\n    }\n    _onSearchChange(event) {\n        const searchText = event.target.value;\n        this.setState({ searchText: searchText });\n        void this._debouncedStartSearch.invoke();\n    }\n    _onReplaceChange(event) {\n        this.setState({ replaceText: event.target.value });\n    }\n    _onSearchKeydown(event) {\n        if (event.keyCode === 13) {\n            event.preventDefault();\n            event.stopPropagation();\n            this._executeSearch(!event.shiftKey);\n        }\n        else if (event.keyCode === 27) {\n            event.preventDefault();\n            event.stopPropagation();\n            this._onClose();\n        }\n    }\n    _onReplaceKeydown(event) {\n        if (event.keyCode === 13) {\n            event.preventDefault();\n            event.stopPropagation();\n            this.props.onReplaceCurrent(this.state.replaceText);\n        }\n    }\n    _executeSearch(goForward, searchText, filterChanged = false) {\n        // execute search!\n        let query;\n        const input = searchText ? searchText : this.state.searchText;\n        try {\n            query = Private.parseQuery(input, this.props.overlayState.caseSensitive, this.props.overlayState.useRegex);\n            this.setState({ errorMessage: '' });\n        }\n        catch (e) {\n            this.setState({ errorMessage: e.message });\n            return;\n        }\n        if (Private.regexEqual(this.props.overlayState.query, query) &&\n            !filterChanged) {\n            if (goForward) {\n                this.props.onHightlightNext();\n            }\n            else {\n                this.props.onHighlightPrevious();\n            }\n            return;\n        }\n        this.props.onStartQuery(query, this.state.filters);\n    }\n    _onClose() {\n        // Clean up and close widget.\n        this.props.onEndSearch();\n        this._debouncedStartSearch.dispose();\n    }\n    _onReplaceToggled() {\n        this.setState({\n            replaceEntryShown: !this.state.replaceEntryShown\n        });\n    }\n    _onSearchInputFocus() {\n        if (!this.state.searchInputFocused) {\n            this.setState({ searchInputFocused: true });\n        }\n    }\n    _onSearchInputBlur() {\n        if (this.state.searchInputFocused) {\n            this.setState({ searchInputFocused: false });\n        }\n    }\n    _toggleSearchOutput() {\n        this.setState(prevState => (Object.assign(Object.assign({}, prevState), { filters: Object.assign(Object.assign({}, prevState.filters), { output: !prevState.filters.output }) })), () => this._executeSearch(true, undefined, true));\n    }\n    _toggleFiltersOpen() {\n        this.setState(prevState => ({\n            filtersOpen: !prevState.filtersOpen\n        }));\n    }\n    render() {\n        const showReplace = !this.props.isReadOnly && this.state.replaceEntryShown;\n        const showFilter = this.props.hasOutputs;\n        const filterToggle = showFilter ? (React.createElement(FilterToggle, { enabled: this.state.filtersOpen, toggleEnabled: () => this._toggleFiltersOpen() })) : null;\n        const filter = showFilter ? (React.createElement(FilterSelection, { key: 'filter', canToggleOutput: !showReplace, searchOutput: this.state.filters.output, toggleOutput: this._toggleSearchOutput })) : null;\n        const icon = this.state.replaceEntryShown ? caretDownIcon : caretRightIcon;\n        // TODO: Error messages from regex are not currently localizable.\n        return [\n            React.createElement(\"div\", { className: OVERLAY_ROW_CLASS, key: 0 },\n                this.props.isReadOnly ? (React.createElement(\"div\", { className: TOGGLE_PLACEHOLDER })) : (React.createElement(\"button\", { className: TOGGLE_WRAPPER, onClick: () => this._onReplaceToggled(), tabIndex: 1 },\n                    React.createElement(icon.react, { className: `${REPLACE_TOGGLE_CLASS} ${BUTTON_CONTENT_CLASS}`, tag: \"span\", elementPosition: \"center\", height: \"20px\", width: \"20px\" }))),\n                React.createElement(SearchEntry, { useRegex: this.props.overlayState.useRegex, caseSensitive: this.props.overlayState.caseSensitive, onCaseSensitiveToggled: () => {\n                        this.props.onCaseSensitiveToggled();\n                        this._executeSearch(true);\n                    }, onRegexToggled: () => {\n                        this.props.onRegexToggled();\n                        this._executeSearch(true);\n                    }, onKeydown: (e) => this._onSearchKeydown(e), onChange: (e) => this._onSearchChange(e), onInputFocus: this._onSearchInputFocus.bind(this), onInputBlur: this._onSearchInputBlur.bind(this), inputFocused: this.state.searchInputFocused, searchText: this.state.searchText, forceFocus: this.props.overlayState.forceFocus, translator: this.translator }),\n                React.createElement(SearchIndices, { currentIndex: this.props.overlayState.currentIndex, totalMatches: this.props.overlayState.totalMatches }),\n                React.createElement(UpDownButtons, { onHighlightPrevious: () => this._executeSearch(false), onHightlightNext: () => this._executeSearch(true) }),\n                showReplace ? null : filterToggle,\n                React.createElement(\"button\", { className: BUTTON_WRAPPER_CLASS, onClick: () => this._onClose(), tabIndex: 9 },\n                    React.createElement(closeIcon.react, { className: \"jp-icon-hover\", elementPosition: \"center\", height: \"16px\", width: \"16px\" }))),\n            React.createElement(\"div\", { className: OVERLAY_ROW_CLASS, key: 1 }, showReplace ? (React.createElement(React.Fragment, null,\n                React.createElement(ReplaceEntry, { onReplaceKeydown: (e) => this._onReplaceKeydown(e), onChange: (e) => this._onReplaceChange(e), onReplaceCurrent: () => this.props.onReplaceCurrent(this.state.replaceText), onReplaceAll: () => this.props.onReplaceAll(this.state.replaceText), replaceText: this.state.replaceText, ref: this.replaceEntryRef, translator: this.translator }),\n                React.createElement(\"div\", { className: SPACER_CLASS }),\n                filterToggle)) : null),\n            this.state.filtersOpen ? filter : null,\n            React.createElement(\"div\", { className: REGEX_ERROR_CLASS, hidden: !!this.state.errorMessage && this.state.errorMessage.length === 0, key: 3 }, this.state.errorMessage)\n        ];\n    }\n}\nexport function createSearchOverlay(options) {\n    const { widgetChanged, overlayState, onCaseSensitiveToggled, onRegexToggled, onHightlightNext, onHighlightPrevious, onStartQuery, onReplaceCurrent, onReplaceAll, onEndSearch, isReadOnly, hasOutputs, translator } = options;\n    const widget = ReactWidget.create(React.createElement(UseSignal, { signal: widgetChanged, initialArgs: overlayState }, (_, args) => {\n        return (React.createElement(SearchOverlay, { onCaseSensitiveToggled: onCaseSensitiveToggled, onRegexToggled: onRegexToggled, onHightlightNext: onHightlightNext, onHighlightPrevious: onHighlightPrevious, onStartQuery: onStartQuery, onEndSearch: onEndSearch, onReplaceCurrent: onReplaceCurrent, onReplaceAll: onReplaceAll, overlayState: args, isReadOnly: isReadOnly, hasOutputs: hasOutputs, translator: translator }));\n    }));\n    widget.addClass(OVERLAY_CLASS);\n    return widget;\n}\nvar Private;\n(function (Private) {\n    function parseQuery(queryString, caseSensitive, regex) {\n        const flag = caseSensitive ? 'g' : 'gi';\n        // escape regex characters in query if its a string search\n        const queryText = regex\n            ? queryString\n            : queryString.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&');\n        let ret;\n        ret = new RegExp(queryText, flag);\n        if (ret.test('')) {\n            ret = /x^/;\n        }\n        return ret;\n    }\n    Private.parseQuery = parseQuery;\n    function regexEqual(a, b) {\n        if (!a || !b) {\n            return false;\n        }\n        return (a.source === b.source &&\n            a.global === b.global &&\n            a.ignoreCase === b.ignoreCase &&\n            a.multiline === b.multiline);\n    }\n    Private.regexEqual = regexEqual;\n})(Private || (Private = {}));\n//# sourceMappingURL=searchoverlay.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { createSearchOverlay } from './searchoverlay';\nimport { MainAreaWidget } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Signal } from '@lumino/signaling';\nimport { Widget } from '@lumino/widgets';\n/**\n * Represents a search on a single widget.\n */\nexport class SearchInstance {\n    constructor(widget, searchProvider, translator) {\n        this._displayState = {\n            currentIndex: 0,\n            totalMatches: 0,\n            caseSensitive: false,\n            useRegex: false,\n            searchText: '',\n            query: null,\n            errorMessage: '',\n            searchInputFocused: true,\n            replaceInputFocused: false,\n            forceFocus: true,\n            replaceText: '',\n            replaceEntryShown: false,\n            filters: { output: true },\n            filtersOpen: false\n        };\n        this._displayUpdateSignal = new Signal(this);\n        this._isDisposed = false;\n        this._disposed = new Signal(this);\n        this.translator = translator || nullTranslator;\n        this._widget = widget;\n        this._activeProvider = searchProvider;\n        const initialQuery = this._activeProvider.getInitialQuery(this._widget);\n        this._displayState.searchText = initialQuery || '';\n        this._searchWidget = createSearchOverlay({\n            widgetChanged: this._displayUpdateSignal,\n            overlayState: this._displayState,\n            onCaseSensitiveToggled: this._onCaseSensitiveToggled.bind(this),\n            onRegexToggled: this._onRegexToggled.bind(this),\n            onHightlightNext: this._highlightNext.bind(this),\n            onHighlightPrevious: this._highlightPrevious.bind(this),\n            onStartQuery: this._startQuery.bind(this),\n            onReplaceCurrent: this._replaceCurrent.bind(this),\n            onReplaceAll: this._replaceAll.bind(this),\n            onEndSearch: this.dispose.bind(this),\n            isReadOnly: this._activeProvider.isReadOnly,\n            hasOutputs: this._activeProvider.hasOutputs || false,\n            translator: this.translator\n        });\n        this._widget.disposed.connect(() => {\n            this.dispose();\n        });\n        this._searchWidget.disposed.connect(() => {\n            this._widget.activate();\n            this.dispose();\n        });\n        // TODO: this does not update if the toolbar changes height.\n        if (this._widget instanceof MainAreaWidget) {\n            // Offset the position of the search widget to not cover the toolbar.\n            this._searchWidget.node.style.top = `${this._widget.toolbar.node.clientHeight}px`;\n        }\n        this._displaySearchWidget();\n    }\n    /**\n     * The search widget.\n     */\n    get searchWidget() {\n        return this._searchWidget;\n    }\n    /**\n     * The search provider.\n     */\n    get provider() {\n        return this._activeProvider;\n    }\n    /**\n     * Focus the search widget input.\n     */\n    focusInput() {\n        this._displayState.forceFocus = true;\n        this._displayState.searchInputFocused = true;\n        // Trigger a rerender without resetting the forceFocus.\n        this._displayUpdateSignal.emit(this._displayState);\n        this._displayState.forceFocus = false;\n    }\n    /**\n     * If there is a replace box, show it.\n     */\n    showReplace() {\n        this._displayState.replaceEntryShown = true;\n    }\n    /**\n     * Updates the match index and total display in the search widget.\n     */\n    updateIndices() {\n        this._displayState.totalMatches = this._activeProvider.matches.length;\n        this._displayState.currentIndex = this._activeProvider.currentMatchIndex;\n        this._updateDisplay();\n    }\n    _updateDisplay() {\n        // Reset the focus attribute to make sure we don't steal focus.\n        this._displayState.forceFocus = false;\n        // Trigger a rerender\n        this._displayUpdateSignal.emit(this._displayState);\n    }\n    async _startQuery(query, filters) {\n        // save the last query (or set it to the current query if this is the first)\n        if (this._activeProvider && this._displayState.query) {\n            await this._activeProvider.endQuery();\n        }\n        this._displayState.query = query;\n        this._displayState.filters = filters;\n        await this._activeProvider.startQuery(query, this._widget, filters);\n        this.updateIndices();\n        // this signal should get injected when the widget is\n        // created and hooked up to react!\n        this._activeProvider.changed.connect(this.updateIndices, this);\n    }\n    async _replaceCurrent(newText) {\n        if (this._activeProvider && this._displayState.query) {\n            await this._activeProvider.replaceCurrentMatch(newText);\n            this.updateIndices();\n        }\n    }\n    async _replaceAll(newText) {\n        if (this._activeProvider && this._displayState.query) {\n            await this._activeProvider.replaceAllMatches(newText);\n            this.updateIndices();\n        }\n    }\n    /**\n     * Dispose of the resources held by the search instance.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        // If a query hasn't been executed yet, no need to call endSearch\n        if (this._displayState.query) {\n            void this._activeProvider.endSearch();\n        }\n        this._searchWidget.dispose();\n        this._disposed.emit(undefined);\n        Signal.clearData(this);\n    }\n    /**\n     * Test if the object has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * A signal emitted when the object is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * Display search widget.\n     */\n    _displaySearchWidget() {\n        if (!this._searchWidget.isAttached) {\n            Widget.attach(this._searchWidget, this._widget.node);\n        }\n    }\n    async _highlightNext() {\n        if (!this._displayState.query) {\n            return;\n        }\n        await this._activeProvider.highlightNext();\n        this.updateIndices();\n    }\n    async _highlightPrevious() {\n        if (!this._displayState.query) {\n            return;\n        }\n        await this._activeProvider.highlightPrevious();\n        this.updateIndices();\n    }\n    _onCaseSensitiveToggled() {\n        this._displayState.caseSensitive = !this._displayState.caseSensitive;\n        this._updateDisplay();\n    }\n    _onRegexToggled() {\n        this._displayState.useRegex = !this._displayState.useRegex;\n        this._updateDisplay();\n    }\n}\n//# sourceMappingURL=searchinstance.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { Signal } from '@lumino/signaling';\nexport class SearchProviderRegistry {\n    constructor() {\n        this._changed = new Signal(this);\n        this._providerMap = new Map();\n    }\n    /**\n     * Add a provider to the registry.\n     *\n     * @param key - The provider key.\n     * @returns A disposable delegate that, when disposed, deregisters the given search provider\n     */\n    register(key, provider) {\n        this._providerMap.set(key, provider);\n        this._changed.emit();\n        return new DisposableDelegate(() => {\n            this._providerMap.delete(key);\n            this._changed.emit();\n        });\n    }\n    /**\n     * Returns a matching provider for the widget.\n     *\n     * @param widget - The widget to search over.\n     * @returns the search provider, or undefined if none exists.\n     */\n    getProviderForWidget(widget) {\n        return this._findMatchingProvider(this._providerMap, widget);\n    }\n    /**\n     * Signal that emits when a new search provider has been registered\n     * or removed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    _findMatchingProvider(providerMap, widget) {\n        // iterate through all providers and ask each one if it can search on the\n        // widget.\n        for (const P of providerMap.values()) {\n            if (P.canSearchOn(widget)) {\n                return new P();\n            }\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=searchproviderregistry.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The search provider registry token.\n */\nexport const ISearchProviderRegistry = new Token('@jupyterlab/documentsearch:ISearchProviderRegistry');\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { MainAreaWidget } from '@jupyterlab/apputils';\nimport { CodeMirrorEditor } from '@jupyterlab/codemirror';\nimport { FileEditor } from '@jupyterlab/fileeditor';\nimport * as CodeMirror from 'codemirror';\nimport { Signal } from '@lumino/signaling';\nexport class CodeMirrorSearchProvider {\n    constructor() {\n        /**\n         * Set to true if the widget under search is read-only, false\n         * if it is editable.  Will be used to determine whether to show\n         * the replace option.\n         */\n        this.isReadOnly = false;\n        /**\n         * Set whether or not the CodemirrorSearchProvider will wrap to the beginning\n         * or end of the document on invocations of highlightNext or highlightPrevious, respectively\n         */\n        this.isSubProvider = false;\n        this._matchState = {};\n        this._changed = new Signal(this);\n    }\n    /**\n     * Get an initial query value if applicable so that it can be entered\n     * into the search box as an initial query\n     *\n     * @returns Initial value used to populate the search box.\n     */\n    getInitialQuery(searchTarget) {\n        const cm = searchTarget.content.editor;\n        const selection = cm.doc.getSelection();\n        // if there are newlines, just return empty string\n        return selection.search(/\\r?\\n|\\r/g) === -1 ? selection : '';\n    }\n    /**\n     * Initialize the search using the provided options.  Should update the UI\n     * to highlight all matches and \"select\" whatever the first match should be.\n     *\n     * @param query A RegExp to be use to perform the search\n     * @param searchTarget The widget to be searched\n     * @param [filters={}] Filter parameters to pass to provider\n     *\n     * @returns A promise that resolves with a list of all matches\n     */\n    async startQuery(query, searchTarget, filters = {}) {\n        if (!CodeMirrorSearchProvider.canSearchOn(searchTarget)) {\n            throw new Error('Cannot find Codemirror instance to search');\n        }\n        // canSearchOn is a type guard that guarantees the type of .editor\n        this._cm = searchTarget.content.editor;\n        return this._startQuery(query);\n    }\n    /**\n     * Initialize the search using a CodeMirrorEditor object.\n     */\n    async startQueryCodeMirror(query, searchTarget) {\n        this._cm = searchTarget;\n        return this._startQuery(query, false);\n    }\n    refreshOverlay() {\n        this._refreshOverlay();\n    }\n    async _startQuery(query, refreshOverlay = true) {\n        // no point in removing overlay in the middle of the search\n        await this.endQuery(false);\n        this._query = query;\n        CodeMirror.on(this._cm.doc, 'change', this._onDocChanged.bind(this));\n        if (refreshOverlay) {\n            this._refreshOverlay();\n        }\n        this._setInitialMatches(query);\n        const matches = this._parseMatchesFromState();\n        if (matches.length === 0) {\n            return [];\n        }\n        if (!this.isSubProvider) {\n            const cursorMatch = this._findNext(false);\n            const match = cursorMatch &&\n                this._matchState[cursorMatch.from.line][cursorMatch.from.ch];\n            this._currentMatch = match;\n        }\n        return matches;\n    }\n    /**\n     * Clears state of a search provider to prepare for startQuery to be called\n     * in order to start a new query or refresh an existing one.\n     *\n     * @returns A promise that resolves when the search provider is ready to\n     * begin a new search.\n     */\n    async endQuery(removeOverlay = true) {\n        this._matchState = {};\n        this._currentMatch = null;\n        if (removeOverlay) {\n            this._cm.removeOverlay(this._overlay);\n        }\n        const from = this._cm.getCursor('from');\n        const to = this._cm.getCursor('to');\n        // Setting a reverse selection to allow search-as-you-type to maintain the\n        // current selected match.  See comment in _findNext for more details.\n        if (from !== to) {\n            this._cm.setSelection({\n                start: this._toEditorPos(to),\n                end: this._toEditorPos(from)\n            });\n        }\n        CodeMirror.off(this._cm.doc, 'change', this._onDocChanged.bind(this));\n    }\n    /**\n     * Resets UI state, removes all matches.\n     *\n     * @returns A promise that resolves when all state has been cleaned up.\n     */\n    async endSearch() {\n        if (!this.isSubProvider) {\n            this._cm.focus();\n        }\n        return this.endQuery();\n    }\n    /**\n     * Move the current match indicator to the next match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightNext() {\n        const cursorMatch = this._findNext(false);\n        if (!cursorMatch) {\n            return;\n        }\n        const match = this._matchState[cursorMatch.from.line][cursorMatch.from.ch];\n        this._currentMatch = match;\n        return match;\n    }\n    /**\n     * Move the current match indicator to the previous match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightPrevious() {\n        const cursorMatch = this._findNext(true);\n        if (!cursorMatch) {\n            return;\n        }\n        const match = this._matchState[cursorMatch.from.line][cursorMatch.from.ch];\n        this._currentMatch = match;\n        return match;\n    }\n    /**\n     * Replace the currently selected match with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceCurrentMatch(newText) {\n        // If the current selection exactly matches the current match,\n        // replace it.  Otherwise, just select the next match after the cursor.\n        let replaceOccurred = false;\n        if (this._currentMatchIsSelected()) {\n            const cursor = this._cm.getSearchCursor(this._query, this._cm.getCursor('from'), !this._query.ignoreCase);\n            if (!cursor.findNext()) {\n                return replaceOccurred;\n            }\n            replaceOccurred = true;\n            cursor.replace(newText);\n        }\n        await this.highlightNext();\n        return replaceOccurred;\n    }\n    /**\n     * Replace all matches in the notebook with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceAllMatches(newText) {\n        let replaceOccurred = false;\n        return new Promise((resolve, _) => {\n            this._cm.operation(() => {\n                const cursor = this._cm.getSearchCursor(this._query, undefined, !this._query.ignoreCase);\n                while (cursor.findNext()) {\n                    replaceOccurred = true;\n                    cursor.replace(newText);\n                }\n                this._matchState = {};\n                this._currentMatch = null;\n                resolve(replaceOccurred);\n            });\n        });\n    }\n    /**\n     * Report whether or not this provider has the ability to search on the given object\n     */\n    static canSearchOn(domain) {\n        return (domain instanceof MainAreaWidget &&\n            domain.content instanceof FileEditor &&\n            domain.content.editor instanceof CodeMirrorEditor);\n    }\n    /**\n     * The same list of matches provided by the startQuery promise resolution\n     */\n    get matches() {\n        return this._parseMatchesFromState();\n    }\n    get currentMatch() {\n        return this._currentMatch;\n    }\n    /**\n     * Signal indicating that something in the search has changed, so the UI should update\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The current index of the selected match.\n     */\n    get currentMatchIndex() {\n        if (!this._currentMatch) {\n            return null;\n        }\n        return this._currentMatch.index;\n    }\n    clearSelection() {\n        return undefined;\n    }\n    get editor() {\n        return this._cm;\n    }\n    _onDocChanged(_, changeObj) {\n        var _a, _b;\n        // If we get newlines added/removed, the line numbers across the\n        // match state are all shifted, so here we need to recalculate it\n        if (changeObj.text.length > 1 || ((_b = (_a = changeObj.removed) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 1) {\n            this._setInitialMatches(this._query);\n            this._changed.emit(undefined);\n        }\n    }\n    _refreshOverlay() {\n        this._cm.operation(() => {\n            // clear search first\n            this._cm.removeOverlay(this._overlay);\n            this._overlay = this._getSearchOverlay();\n            this._cm.addOverlay(this._overlay);\n            this._changed.emit(undefined);\n        });\n    }\n    /**\n     * Do a full search on the entire document.\n     *\n     * This manually constructs the initial match state across the whole\n     * document. This must be done manually because the codemirror overlay\n     * is lazy-loaded, so it will only tokenize lines that are in or near\n     * the viewport.  This is sufficient for efficiently maintaining the\n     * state when changes are made to the document, as changes occur in or\n     * near the viewport, but to scan the whole document, a manual search\n     * across the entire content is required.\n     *\n     * @param query The search term\n     */\n    _setInitialMatches(query) {\n        this._matchState = {};\n        const start = CodeMirror.Pos(this._cm.doc.firstLine(), 0);\n        const end = CodeMirror.Pos(this._cm.doc.lastLine());\n        const content = this._cm.doc.getRange(start, end);\n        const lines = content.split('\\n');\n        const totalMatchIndex = 0;\n        lines.forEach((line, lineNumber) => {\n            query.lastIndex = 0;\n            let match = query.exec(line);\n            while (match) {\n                const col = match.index;\n                const matchObj = {\n                    text: match[0],\n                    line: lineNumber,\n                    column: col,\n                    fragment: line,\n                    index: totalMatchIndex\n                };\n                if (!this._matchState[lineNumber]) {\n                    this._matchState[lineNumber] = {};\n                }\n                this._matchState[lineNumber][col] = matchObj;\n                match = query.exec(line);\n            }\n        });\n    }\n    _getSearchOverlay() {\n        return {\n            /**\n             * Token function is called when a line needs to be processed -\n             * when the overlay is initially created, it's called on all lines;\n             * when a line is modified and needs to be re-evaluated, it's called\n             * on just that line.\n             *\n             * This implementation of the token function both constructs/maintains\n             * the overlay and keeps track of the match state as the document is\n             * updated while a search is active.\n             */\n            token: (stream) => {\n                const currentPos = stream.pos;\n                this._query.lastIndex = currentPos;\n                const lineText = stream.string;\n                const match = this._query.exec(lineText);\n                const line = stream.lineOracle.line;\n                // If starting at position 0, the tokenization of this line has just started.\n                // Blow away everything on this line in the state so it can be updated.\n                if (stream.start === currentPos &&\n                    currentPos === 0 &&\n                    !!this._matchState[line]) {\n                    this._matchState[line] = {};\n                }\n                if (match && match.index === currentPos) {\n                    // found match, add it to state\n                    const matchLength = match[0].length;\n                    const matchObj = {\n                        text: lineText.substr(currentPos, matchLength),\n                        line: line,\n                        column: currentPos,\n                        fragment: lineText,\n                        index: 0 // fill in index when flattening, later\n                    };\n                    if (!this._matchState[line]) {\n                        this._matchState[line] = {};\n                    }\n                    this._matchState[line][currentPos] = matchObj;\n                    // move the stream along and return searching style for the token\n                    stream.pos += matchLength || 1;\n                    // if the last thing on the line was a match, make sure we still\n                    // emit the changed signal so the display can pick up the updates\n                    if (stream.eol()) {\n                        this._changed.emit(undefined);\n                    }\n                    return 'searching';\n                }\n                else if (match) {\n                    // there's a match in the stream, advance the stream to its position\n                    stream.pos = match.index;\n                }\n                else {\n                    // no matches, consume the rest of the stream\n                    this._changed.emit(undefined);\n                    stream.skipToEnd();\n                }\n            }\n        };\n    }\n    _findNext(reverse) {\n        return this._cm.operation(() => {\n            const caseSensitive = this._query.ignoreCase;\n            // In order to support search-as-you-type, we needed a way to allow the first\n            // match to be selected when a search is started, but prevent the selected\n            // search to move for each new keypress.  To do this, when a search is ended,\n            // the cursor is reversed, putting the head at the 'from' position.  When a new\n            // search is started, the cursor we want is at the 'from' position, so that the same\n            // match is selected when the next key is entered (if it is still a match).\n            //\n            // When toggling through a search normally, the cursor is always set in the forward\n            // direction, so head is always at the 'to' position.  That way, if reverse = false,\n            // the search proceeds from the 'to' position during normal toggling.  If reverse = true,\n            // the search always proceeds from the 'anchor' position, which is at the 'from'.\n            const cursorToGet = reverse ? 'anchor' : 'head';\n            const lastPosition = this._cm.getCursor(cursorToGet);\n            const position = this._toEditorPos(lastPosition);\n            let cursor = this._cm.getSearchCursor(this._query, lastPosition, !caseSensitive);\n            if (!cursor.find(reverse)) {\n                // if we don't want to loop, no more matches found, reset the cursor and exit\n                if (this.isSubProvider) {\n                    this._cm.setCursorPosition(position, { scroll: false });\n                    this._currentMatch = null;\n                    return null;\n                }\n                // if we do want to loop, try searching from the bottom/top\n                const startOrEnd = reverse\n                    ? CodeMirror.Pos(this._cm.lastLine())\n                    : CodeMirror.Pos(this._cm.firstLine(), 0);\n                cursor = this._cm.getSearchCursor(this._query, startOrEnd, !caseSensitive);\n                if (!cursor.find(reverse)) {\n                    return null;\n                }\n            }\n            const fromPos = cursor.from();\n            const toPos = cursor.to();\n            const selRange = {\n                start: {\n                    line: fromPos.line,\n                    column: fromPos.ch\n                },\n                end: {\n                    line: toPos.line,\n                    column: toPos.ch\n                }\n            };\n            this._cm.setSelection(selRange);\n            this._cm.scrollIntoView({\n                from: fromPos,\n                to: toPos\n            }, 100);\n            return {\n                from: fromPos,\n                to: toPos\n            };\n        });\n    }\n    _parseMatchesFromState() {\n        let index = 0;\n        // Flatten state map and update the index of each match\n        const matches = Object.keys(this._matchState).reduce((result, lineNumber) => {\n            const lineKey = parseInt(lineNumber, 10);\n            const lineMatches = this._matchState[lineKey];\n            Object.keys(lineMatches).forEach((pos) => {\n                const posKey = parseInt(pos, 10);\n                const match = lineMatches[posKey];\n                match.index = index;\n                index += 1;\n                result.push(match);\n            });\n            return result;\n        }, []);\n        return matches;\n    }\n    _toEditorPos(posIn) {\n        return {\n            line: posIn.line,\n            column: posIn.ch\n        };\n    }\n    _currentMatchIsSelected() {\n        if (!this._currentMatch) {\n            return false;\n        }\n        const currentSelection = this._cm.getSelection();\n        const currentSelectionLength = currentSelection.end.column - currentSelection.start.column;\n        const selectionIsOneLine = currentSelection.start.line === currentSelection.end.line;\n        return (this._currentMatch.line === currentSelection.start.line &&\n            this._currentMatch.column === currentSelection.start.column &&\n            this._currentMatch.text.length === currentSelectionLength &&\n            selectionIsOneLine);\n    }\n}\nexport class SearchState {\n}\n//# sourceMappingURL=codemirrorsearchprovider.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Signal } from '@lumino/signaling';\nimport { Widget } from '@lumino/widgets';\nconst FOUND_CLASSES = ['cm-string', 'cm-overlay', 'cm-searching'];\nconst SELECTED_CLASSES = ['CodeMirror-selectedtext'];\nexport class GenericSearchProvider {\n    constructor() {\n        /**\n         * Set to true if the widget under search is read-only, false\n         * if it is editable.  Will be used to determine whether to show\n         * the replace option.\n         */\n        this.isReadOnly = true;\n        /**\n         * Set whether or not this will wrap to the beginning\n         * or end of the document on invocations of highlightNext or highlightPrevious, respectively\n         */\n        this.isSubProvider = false;\n        this._matches = [];\n        this._mutationObserver = new MutationObserver(this._onWidgetChanged.bind(this));\n        this._changed = new Signal(this);\n    }\n    /**\n     * Get an initial query value if applicable so that it can be entered\n     * into the search box as an initial query\n     *\n     * @returns Initial value used to populate the search box.\n     */\n    getInitialQuery(searchTarget) {\n        return '';\n    }\n    /**\n     * Initialize the search using the provided options.  Should update the UI\n     * to highlight all matches and \"select\" whatever the first match should be.\n     *\n     * @param query A RegExp to be use to perform the search\n     * @param searchTarget The widget to be searched\n     * @param [filters={}] Filter parameters to pass to provider\n     *\n     * @returns A promise that resolves with a list of all matches\n     */\n    async startQuery(query, searchTarget, filters = {}) {\n        const that = this; // eslint-disable-line\n        // No point in removing overlay in the middle of the search\n        await this.endQuery(false);\n        this._widget = searchTarget;\n        this._query = query;\n        this._mutationObserver.disconnect();\n        const matches = [];\n        const walker = document.createTreeWalker(this._widget.node, NodeFilter.SHOW_TEXT, {\n            acceptNode: node => {\n                // Filter subtrees of UNSUPPORTED_ELEMENTS and nodes that\n                // do not contain our search text\n                let parentElement = node.parentElement;\n                while (parentElement !== this._widget.node) {\n                    if (parentElement.nodeName in\n                        GenericSearchProvider.UNSUPPORTED_ELEMENTS) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                    parentElement = parentElement.parentElement;\n                }\n                return that._query.test(node.textContent)\n                    ? NodeFilter.FILTER_ACCEPT\n                    : NodeFilter.FILTER_REJECT;\n            }\n        }, false);\n        const nodes = [];\n        const originalNodes = [];\n        // We MUST gather nodes first, otherwise the updates below will find each result twice\n        let node = walker.nextNode();\n        while (node) {\n            nodes.push(node);\n            /* We store them here as we want to avoid saving a modified one\n             * This happens with something like this: <pre><span>Hello</span> world</pre> and looking for o\n             * The o in world is found after the o in hello which means the pre could have been modified already\n             * While there may be a better data structure to do this for performance, this was easy to reason about.\n             */\n            originalNodes.push(node.parentElement.cloneNode(true));\n            node = walker.nextNode();\n        }\n        // We'll need to copy the regexp to ensure its 'g' and that we start the index count from 0\n        const flags = this._query.flags.indexOf('g') === -1 ? query.flags + 'g' : query.flags;\n        nodes.forEach((node, nodeIndex) => {\n            const q = new RegExp(query.source, flags);\n            const subsections = [];\n            let match = q.exec(node.textContent);\n            while (match) {\n                subsections.push({\n                    start: match.index,\n                    end: match.index + match[0].length,\n                    text: match[0]\n                });\n                match = q.exec(node.textContent);\n            }\n            const originalNode = originalNodes[nodeIndex];\n            const originalLength = node.textContent.length; // Node length will change below\n            let lastNodeAdded = null;\n            // Go backwards as index may change if we go forwards\n            const newMatches = [];\n            for (let idx = subsections.length - 1; idx >= 0; --idx) {\n                const { start, end, text } = subsections[idx];\n                // TODO: support tspan for svg when svg support is added\n                const spannedNode = document.createElement('span');\n                spannedNode.classList.add(...FOUND_CLASSES);\n                spannedNode.innerText = text;\n                // Splice the text out before we add it back in with a span\n                node.textContent = `${node.textContent.slice(0, start)}${node.textContent.slice(end)}`;\n                // Are we replacing from the start?\n                if (start === 0) {\n                    node.parentNode.prepend(spannedNode);\n                    // Are we replacing at the end?\n                }\n                else if (end === originalLength) {\n                    node.parentNode.append(spannedNode);\n                    // Are the two results are adjacent to each other?\n                }\n                else if (lastNodeAdded && end === subsections[idx + 1].start) {\n                    node.parentNode.insertBefore(spannedNode, lastNodeAdded);\n                    // Ok, we are replacing somewhere in the middle\n                }\n                else {\n                    // We know this is Text as we filtered for this in the walker above\n                    const endText = node.splitText(start);\n                    node.parentNode.insertBefore(spannedNode, endText);\n                }\n                lastNodeAdded = spannedNode;\n                newMatches.unshift({\n                    text,\n                    fragment: '',\n                    line: 0,\n                    column: 0,\n                    index: -1,\n                    // GenericSearchFields\n                    matchesIndex: -1,\n                    indexInOriginal: idx,\n                    spanElement: spannedNode,\n                    originalNode\n                });\n            }\n            matches.push(...newMatches);\n        });\n        matches.forEach((match, idx) => {\n            // This may be changed when this is a subprovider :/\n            match.index = idx;\n            // TODO: matchesIndex is declared as readonly. Why are we setting it here?\n            match.matchesIndex = idx;\n        });\n        if (!this.isSubProvider && matches.length > 0) {\n            this._currentMatch = matches[0];\n        }\n        // Watch for future changes:\n        this._mutationObserver.observe(this._widget.node, \n        // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserverInit\n        {\n            attributes: false,\n            characterData: true,\n            childList: true,\n            subtree: true\n        });\n        this._matches = matches;\n        return this._matches;\n    }\n    refreshOverlay() {\n        // We don't have an overlay, we are directly changing the DOM\n    }\n    /**\n     * Clears state of a search provider to prepare for startQuery to be called\n     * in order to start a new query or refresh an existing one.\n     *\n     * @returns A promise that resolves when the search provider is ready to\n     * begin a new search.\n     */\n    async endQuery(removeOverlay = true) {\n        this._matches.forEach(match => {\n            // We already took care of this parent with another match\n            if (match.indexInOriginal !== 0) {\n                return;\n            }\n            match.spanElement.parentElement.replaceWith(match.originalNode);\n        });\n        this._matches = [];\n        this._currentMatch = null;\n        this._mutationObserver.disconnect();\n    }\n    /**\n     * Resets UI state, removes all matches.\n     *\n     * @returns A promise that resolves when all state has been cleaned up.\n     */\n    async endSearch() {\n        return this.endQuery();\n    }\n    /**\n     * Move the current match indicator to the next match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightNext() {\n        return this._highlightNext(false);\n    }\n    /**\n     * Move the current match indicator to the previous match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightPrevious() {\n        return this._highlightNext(true);\n    }\n    _highlightNext(reverse) {\n        if (this._matches.length === 0) {\n            return undefined;\n        }\n        if (!this._currentMatch) {\n            this._currentMatch = reverse\n                ? this._matches[this.matches.length - 1]\n                : this._matches[0];\n        }\n        else {\n            this._currentMatch.spanElement.classList.remove(...SELECTED_CLASSES);\n            let nextIndex = reverse\n                ? this._currentMatch.matchesIndex - 1\n                : this._currentMatch.matchesIndex + 1;\n            // When we are a subprovider, don't loop\n            if (this.isSubProvider) {\n                if (nextIndex < 0 || nextIndex >= this._matches.length) {\n                    this._currentMatch = null;\n                    return undefined;\n                }\n            }\n            // Cheap way to make this a circular buffer\n            nextIndex = (nextIndex + this._matches.length) % this._matches.length;\n            this._currentMatch = this._matches[nextIndex];\n        }\n        if (this._currentMatch) {\n            this._currentMatch.spanElement.classList.add(...SELECTED_CLASSES);\n            // If not in view, scroll just enough to see it\n            if (!elementInViewport(this._currentMatch.spanElement)) {\n                this._currentMatch.spanElement.scrollIntoView(reverse);\n            }\n            this._currentMatch.spanElement.focus();\n        }\n        return this._currentMatch;\n    }\n    /**\n     * Replace the currently selected match with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceCurrentMatch(newText) {\n        return Promise.resolve(false);\n    }\n    /**\n     * Replace all matches in the notebook with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceAllMatches(newText) {\n        // This is read only, but we could loosen this in theory for input boxes...\n        return Promise.resolve(false);\n    }\n    /**\n     * Report whether or not this provider has the ability to search on the given object\n     */\n    static canSearchOn(domain) {\n        return domain instanceof Widget;\n    }\n    /**\n     * The same list of matches provided by the startQuery promise resolution\n     */\n    get matches() {\n        // Ensure that no other fn can overwrite matches index property\n        // We shallow clone each node\n        return this._matches\n            ? this._matches.map(m => Object.assign({}, m))\n            : this._matches;\n    }\n    /**\n     * Signal indicating that something in the search has changed, so the UI should update\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The current index of the selected match.\n     */\n    get currentMatchIndex() {\n        if (!this._currentMatch) {\n            return null;\n        }\n        return this._currentMatch.index;\n    }\n    get currentMatch() {\n        return this._currentMatch;\n    }\n    clearSelection() {\n        return;\n    }\n    async _onWidgetChanged(mutations, observer) {\n        // This is typically cheap, but we do not control the rate of change or size of the output\n        await this.startQuery(this._query, this._widget);\n        this._changed.emit(undefined);\n    }\n}\n/**\n * We choose opt out as most node types should be searched (e.g. script).\n * Even nodes like <data>, could have innerText we care about.\n *\n * Note: nodeName is capitalized, so we do the same here\n */\nGenericSearchProvider.UNSUPPORTED_ELEMENTS = {\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Document_metadata\n    BASE: true,\n    HEAD: true,\n    LINK: true,\n    META: true,\n    STYLE: true,\n    TITLE: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Sectioning_root\n    BODY: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Content_sectioning\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Text_content\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Inline_text_semantics\n    // Above is searched\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Image_and_multimedia\n    AREA: true,\n    AUDIO: true,\n    IMG: true,\n    MAP: true,\n    TRACK: true,\n    VIDEO: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Embedded_content\n    APPLET: true,\n    EMBED: true,\n    IFRAME: true,\n    NOEMBED: true,\n    OBJECT: true,\n    PARAM: true,\n    PICTURE: true,\n    SOURCE: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Scripting\n    CANVAS: true,\n    NOSCRIPT: true,\n    SCRIPT: true,\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Demarcating_edits\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Table_content\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Forms\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Interactive_elements\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element#Web_Components\n    // Above is searched\n    // Other:\n    SVG: true\n};\nfunction elementInViewport(el) {\n    const boundingClientRect = el.getBoundingClientRect();\n    return (boundingClientRect.top >= 0 &&\n        boundingClientRect.bottom <=\n            (window.innerHeight || document.documentElement.clientHeight) &&\n        boundingClientRect.left >= 0 &&\n        boundingClientRect.right <=\n            (window.innerWidth || document.documentElement.clientWidth));\n}\n//# sourceMappingURL=genericsearchprovider.js.map","import { CodeMirrorSearchProvider } from './codemirrorsearchprovider';\nimport { GenericSearchProvider } from './genericsearchprovider';\nimport { MarkdownCell, CodeCell } from '@jupyterlab/cells';\nimport { NotebookPanel } from '@jupyterlab/notebook';\nimport { ArrayExt } from '@lumino/algorithm';\nimport { Signal } from '@lumino/signaling';\nimport CodeMirror from 'codemirror';\nexport class NotebookSearchProvider {\n    constructor() {\n        /**\n         * Set to true if the widget under search is read-only, false\n         * if it is editable.  Will be used to determine whether to show\n         * the replace option.\n         */\n        this.isReadOnly = false;\n        this.hasOutputs = true;\n        this._searchProviders = [];\n        this._unRenderedMarkdownCells = [];\n        this._cellsWithMatches = [];\n        this._changed = new Signal(this);\n    }\n    /**\n     * Get an initial query value if applicable so that it can be entered\n     * into the search box as an initial query\n     *\n     * @returns Initial value used to populate the search box.\n     */\n    getInitialQuery(searchTarget) {\n        var _a;\n        const activeCell = searchTarget.content.activeCell;\n        const selection = (_a = activeCell === null || activeCell === void 0 ? void 0 : activeCell.editor) === null || _a === void 0 ? void 0 : _a.doc.getSelection();\n        // if there are newlines, just return empty string\n        return (selection === null || selection === void 0 ? void 0 : selection.search(/\\r?\\n|\\r/g)) === -1 ? selection : '';\n    }\n    /**\n     * Initialize the search using the provided options. Should update the UI\n     * to highlight all matches and \"select\" whatever the first match should be.\n     *\n     * @param query A RegExp to be use to perform the search\n     * @param searchTarget The widget to be searched\n     * @param filters Filter parameters to pass to provider\n     *\n     * @returns A promise that resolves with a list of all matches\n     */\n    async startQuery(query, searchTarget, filters) {\n        this._searchTarget = searchTarget;\n        const cells = this._searchTarget.content.widgets;\n        this._filters =\n            !filters || Object.entries(filters).length === 0\n                ? { output: true }\n                : filters;\n        // hide the current notebook widget to prevent expensive layout re-calculation operations\n        this._searchTarget.hide();\n        let indexTotal = 0;\n        const allMatches = [];\n        // For each cell, create a search provider and collect the matches\n        for (const cell of cells) {\n            const cmEditor = cell.editor;\n            const cmSearchProvider = new CodeMirrorSearchProvider();\n            cmSearchProvider.isSubProvider = true;\n            // If a rendered MarkdownCell contains a match, unrender it so that\n            // CodeMirror can show the match(es).  If the MarkdownCell is not\n            // rendered, putting CodeMirror on the page, CodeMirror will not run\n            // the mode, which will prevent the search from occurring.\n            // Keep track so that the cell can be rerendered when the search is ended\n            // or if there are no matches\n            let cellShouldReRender = false;\n            if (cell instanceof MarkdownCell && cell.rendered) {\n                cell.rendered = false;\n                cellShouldReRender = true;\n            }\n            // Unhide hidden cells for the same reason as above\n            if (cell.inputHidden) {\n                cell.inputHidden = false;\n            }\n            // chain promises to ensure indexing is sequential\n            const matchesFromCell = await cmSearchProvider.startQueryCodeMirror(query, cmEditor);\n            if (cell instanceof MarkdownCell) {\n                if (matchesFromCell.length !== 0) {\n                    // un-render markdown cells with matches\n                    this._unRenderedMarkdownCells.push(cell);\n                }\n                else if (cellShouldReRender) {\n                    // was rendered previously, no need to refresh\n                    cell.rendered = true;\n                }\n            }\n            if (matchesFromCell.length !== 0) {\n                cmSearchProvider.refreshOverlay();\n                this._cellsWithMatches.push(cell);\n            }\n            // update the match indices to reflect the whole document index values\n            matchesFromCell.forEach(match => {\n                match.index = match.index + indexTotal;\n            });\n            indexTotal += matchesFromCell.length;\n            // search has been initialized, connect the changed signal\n            cmSearchProvider.changed.connect(this._onSearchProviderChanged, this);\n            allMatches.concat(matchesFromCell);\n            this._searchProviders.push({\n                cell: cell,\n                provider: cmSearchProvider\n            });\n            if (cell instanceof CodeCell && this._filters.output) {\n                const outputProivder = new GenericSearchProvider();\n                outputProivder.isSubProvider = true;\n                const matchesFromOutput = await outputProivder.startQuery(query, cell.outputArea);\n                matchesFromOutput.map(match => {\n                    match.index = match.index + indexTotal;\n                });\n                indexTotal += matchesFromOutput.length;\n                allMatches.concat(matchesFromOutput);\n                outputProivder.changed.connect(this._onSearchProviderChanged, this);\n                this._searchProviders.push({\n                    cell: cell,\n                    provider: outputProivder\n                });\n            }\n        }\n        // show the widget again, recalculation of layout will matter again\n        // and so that the next step will scroll correctly to the first match\n        this._searchTarget.show();\n        this._currentMatch = await this._stepNext(this._updatedCurrentProvider(false));\n        this._refreshCurrentCellEditor();\n        this._refreshCellsEditorsInBackground(this._cellsWithMatches);\n        return allMatches;\n    }\n    /**\n     * Gradually refresh cells in the background so that the user will not\n     * experience frozen interface, `n` cells at a time.\n     */\n    _refreshCellsEditorsInBackground(cells, n = 5) {\n        let i = 0;\n        const refreshNextNCells = () => {\n            for (let stop = i + n; i < stop && i < cells.length; i++) {\n                cells[i].editor.refresh();\n            }\n            if (i < cells.length) {\n                window.setTimeout(refreshNextNCells, 0);\n            }\n        };\n        window.setTimeout(refreshNextNCells, 0);\n    }\n    /**\n     * Refresh the editor in the cell for the current match.\n     */\n    _refreshCurrentCellEditor() {\n        const notebook = this._searchTarget.content;\n        notebook.activeCell.editor.refresh();\n    }\n    /**\n     * Clears state of a search provider to prepare for startQuery to be called\n     * in order to start a new query or refresh an existing one.\n     *\n     * @returns A promise that resolves when the search provider is ready to\n     * begin a new search.\n     */\n    async endQuery() {\n        this._searchTarget.hide();\n        const queriesEnded = [];\n        this._searchProviders.forEach(({ provider }) => {\n            queriesEnded.push(provider.endQuery());\n            provider.changed.disconnect(this._onSearchProviderChanged, this);\n        });\n        Signal.disconnectBetween(this._searchTarget.model.cells, this);\n        this._searchProviders = [];\n        this._currentProvider = null;\n        this._unRenderedMarkdownCells.forEach((cell) => {\n            // Guard against the case where markdown cells have been deleted\n            if (!cell.isDisposed) {\n                cell.rendered = true;\n            }\n        });\n        this._unRenderedMarkdownCells = [];\n        await Promise.all(queriesEnded);\n        this._searchTarget.show();\n        this._refreshCurrentCellEditor();\n        // re-render all non-markdown cells with matches (which were rendered, thus do not need refreshing)\n        this._refreshCellsEditorsInBackground(this._cellsWithMatches.filter((cell) => !(cell instanceof MarkdownCell)));\n        this._cellsWithMatches = [];\n    }\n    /**\n     * Resets UI state, removes all matches.\n     *\n     * @returns A promise that resolves when all state has been cleaned up.\n     */\n    async endSearch() {\n        this._searchTarget.hide();\n        Signal.disconnectBetween(this._searchTarget.model.cells, this);\n        const index = this._searchTarget.content.activeCellIndex;\n        const searchEnded = [];\n        this._searchProviders.forEach(({ provider }) => {\n            searchEnded.push(provider.endSearch());\n            provider.changed.disconnect(this._onSearchProviderChanged, this);\n        });\n        this._searchProviders = [];\n        this._currentProvider = null;\n        this._unRenderedMarkdownCells.forEach((cell) => {\n            cell.rendered = true;\n        });\n        this._unRenderedMarkdownCells = [];\n        this._searchTarget.content.activeCellIndex = index;\n        this._searchTarget.content.mode = 'edit';\n        this._currentMatch = null;\n        await Promise.all(searchEnded);\n        this._searchTarget.show();\n        this._refreshCurrentCellEditor();\n        this._searchTarget = null;\n        // re-render all non-markdown cells with matches (which were rendered, thus do not need refreshing)\n        this._refreshCellsEditorsInBackground(this._cellsWithMatches.filter((cell) => !(cell instanceof MarkdownCell)));\n        this._cellsWithMatches = [];\n    }\n    /**\n     * Move the current match indicator to the next match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightNext() {\n        this._currentMatch = await this._stepNext(this._updatedCurrentProvider(false));\n        return this._currentMatch;\n    }\n    /**\n     * Move the current match indicator to the previous match.\n     *\n     * @returns A promise that resolves once the action has completed.\n     */\n    async highlightPrevious() {\n        this._currentMatch = await this._stepNext(this._updatedCurrentProvider(true), true);\n        return this._currentMatch;\n    }\n    /**\n     * Replace the currently selected match with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceCurrentMatch(newText) {\n        const notebook = this._searchTarget.content;\n        const editor = notebook.activeCell.editor;\n        let replaceOccurred = false;\n        if (this._currentMatchIsSelected(editor)) {\n            const { provider } = this._currentProvider;\n            replaceOccurred = await provider.replaceCurrentMatch(newText);\n            if (replaceOccurred) {\n                this._currentMatch = provider.currentMatch;\n                // If there was a replacement and there is another match, then the CodeMirrorSearchProvider\n                // already highlighted the next match, so we can return early to avoid skipping a match.\n                if (this._currentMatch) {\n                    return replaceOccurred;\n                }\n            }\n        }\n        await this.highlightNext();\n        return replaceOccurred;\n    }\n    /**\n     * Replace all matches in the notebook with the provided text\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceAllMatches(newText) {\n        let replaceOccurred = false;\n        for (const index in this._searchProviders) {\n            const { provider } = this._searchProviders[index];\n            const singleReplaceOccurred = await provider.replaceAllMatches(newText);\n            replaceOccurred = singleReplaceOccurred ? true : replaceOccurred;\n        }\n        this._currentMatch = null;\n        return replaceOccurred;\n    }\n    /**\n     * Report whether or not this provider has the ability to search on the given object\n     */\n    static canSearchOn(domain) {\n        // check to see if the CMSearchProvider can search on the\n        // first cell, false indicates another editor is present\n        return domain instanceof NotebookPanel;\n    }\n    /**\n     * The same list of matches provided by the startQuery promise resolution\n     */\n    get matches() {\n        return [].concat(...this._getMatchesFromCells());\n    }\n    /**\n     * Signal indicating that something in the search has changed, so the UI should update\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The current index of the selected match.\n     */\n    get currentMatchIndex() {\n        if (!this._currentMatch) {\n            return null;\n        }\n        return this._currentMatch.index;\n    }\n    _updatedCurrentProvider(reverse) {\n        if (this._currentProvider &&\n            this._currentProvider.cell === this._searchTarget.content.activeCell) {\n            return this._currentProvider;\n        }\n        let provider;\n        if (!this._currentProvider) {\n            const find = reverse ? ArrayExt.findLastValue : ArrayExt.findFirstValue;\n            provider = find(this._searchProviders, provider => this._searchTarget.content.activeCell === provider.cell);\n        }\n        else {\n            const currentProviderIndex = ArrayExt.firstIndexOf(this._searchProviders, this._currentProvider);\n            const nextProviderIndex = ((reverse ? currentProviderIndex - 1 : currentProviderIndex + 1) +\n                this._searchProviders.length) %\n                this._searchProviders.length;\n            provider = this._searchProviders[nextProviderIndex];\n        }\n        this._currentProvider = provider;\n        return provider;\n    }\n    async _stepNext(currentSearchPair, reverse = false, steps = 0) {\n        const { provider } = currentSearchPair;\n        // highlightNext/Previous will not be able to search rendered MarkdownCells or\n        // hidden code cells, but that is okay here because in startQuery, we unrendered\n        // all cells with matches and unhide all cells\n        const match = reverse\n            ? await provider.highlightPrevious()\n            : await provider.highlightNext();\n        // If there was no match in this cell, try the next cell\n        if (!match) {\n            const providerIndex = this._searchProviders.indexOf(currentSearchPair);\n            const numProviders = this._searchProviders.length;\n            // We have looped around the whole notebook and have searched the original\n            // cell once more and found no matches.  Do not proceed with incrementing the\n            // active cell index so that the active cell doesn't change\n            if (steps === numProviders) {\n                return undefined;\n            }\n            const nextIndex = ((reverse ? providerIndex - 1 : providerIndex + 1) + numProviders) %\n                numProviders;\n            const nextSearchPair = this._searchProviders[nextIndex];\n            if (nextSearchPair.provider instanceof CodeMirrorSearchProvider) {\n                const editor = nextSearchPair.provider.editor;\n                // move the cursor of the next cell to the start/end of the cell so it can\n                // search the whole thing (but don't scroll because we haven't found anything yet)\n                const newPosCM = reverse\n                    ? CodeMirror.Pos(editor.lastLine())\n                    : CodeMirror.Pos(editor.firstLine(), 0);\n                const newPos = {\n                    line: newPosCM.line,\n                    column: newPosCM.ch\n                };\n                editor.setCursorPosition(newPos, { scroll: false });\n            }\n            this._currentProvider = nextSearchPair;\n            return this._stepNext(nextSearchPair, reverse, steps + 1);\n        }\n        const notebook = this._searchTarget.content;\n        notebook.activeCellIndex = notebook.widgets.indexOf(currentSearchPair.cell);\n        return match;\n    }\n    _getMatchesFromCells() {\n        let indexTotal = 0;\n        const result = [];\n        this._searchProviders.forEach(({ provider }) => {\n            const cellMatches = provider.matches;\n            cellMatches.forEach(match => {\n                match.index = match.index + indexTotal;\n            });\n            indexTotal += cellMatches.length;\n            result.push(cellMatches);\n        });\n        return result;\n    }\n    _onSearchProviderChanged() {\n        this._changed.emit(undefined);\n    }\n    _currentMatchIsSelected(cm) {\n        if (!this._currentMatch) {\n            return false;\n        }\n        const currentSelection = cm.getSelection();\n        const currentSelectionLength = currentSelection.end.column - currentSelection.start.column;\n        const selectionIsOneLine = currentSelection.start.line === currentSelection.end.line;\n        return (this._currentMatch.line === currentSelection.start.line &&\n            this._currentMatch.column === currentSelection.start.column &&\n            this._currentMatch.text.length === currentSelectionLength &&\n            selectionIsOneLine);\n    }\n}\n//# sourceMappingURL=notebooksearchprovider.js.map"],"sourceRoot":""}
{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/actions.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/default-toolbar.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/celllist.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/model.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/modelfactory.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/notebooktools.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/widget.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/panel.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/tracker.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/widgetfactory.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/modestatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/truststatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/tokens.js"],"names":["JUPYTER_CELL_MIME","NotebookActions","Private","executed","splitCell","notebook","model","activeCell","state","getState","deselectAll","nbModel","index","activeCellIndex","child","widgets","editor","selections","getSelections","orig","value","text","offsets","i","length","start","getOffsetAt","end","push","clones","clone","cloneCell","type","outputs","clear","slice","replace","cells","beginCompoundOperation","set","insert","endCompoundOperation","handleState","mergeCells","toMerge","toDelete","primary","active","attachments","forEach","isSelectedOrActive","isRawCellModel","isMarkdownCellModel","key","keys","get","toJSON","cellModel","newModel","join","isCodeCellModel","fromJSON","cell","removeValue","MarkdownCell","rendered","deleteCells","insertAbove","contentFactory","createCell","notebookConfig","defaultCell","insertBelow","moveDown","move","select","deselect","moveUp","changeCellType","run","sessionContext","Promise","resolve","promise","runSelected","handleRunState","runAndAdvance","mode","runAndInsert","runAll","renderAllMarkdown","previousIndex","runAllAbove","runAllBelow","replaceSelection","_a","_b","call","selectAbove","possibleNextCell","inputHidden","selectBelow","maxCellIndex","extendSelectionAbove","toTop","extendContiguousSelectionTo","extendSelectionBelow","toBottom","selectAll","copy","copyOrCut","cut","paste","clipboard","Clipboard","hasData","values","getData","newCells","map","cell_type","createCodeCell","createMarkdownCell","createRawCell","deletable","metadata","reverse","remove","undo","redo","toggleAllLineNumbers","config","editorConfig","lineNumbers","code","markdown","raw","newConfig","Object","assign","clearOutputs","each","clearExecution","outputHidden","clearAllOutputs","hideCode","showCode","hideAllCode","showAllCode","hideOutput","showOutput","hideAllOutputs","showAllOutputs","enableOutputScrolling","outputsScrolled","disableOutputScrolling","selectLastRunCell","latestTime","latestCellIdx","cellIndx","execution","JSONExt","undefined","timestamp","toString","startTime","Date","setMarkdownHeader","level","Math","min","max","trust","translator","trans","nullTranslator","load","toArray","trusted","every","trustMessage","__","showDialog","body","buttons","Dialog","label","then","title","result","button","accept","wasFocused","node","contains","document","activeElement","scrollIfNeeded","activate","ElementExt","deletedCells","id","Signal","scroll","rect","inputArea","getBoundingClientRect","scrollToPosition","bottom","lastIndex","selected","filter","all","_c","emit","isTerminating","session","path","CodeCell","recordTiming","reply","splice","isDisposed","content","status","payload","setNextInput","source","newCell","ArrayExt","handlePayload","Error","catch","reason","message","startsWith","ran","runCell","results","update","executionCount","setPrompt","data","cellJSON","setData","newHeader","Array","matches","exec","ToolbarItems","createSaveButton","panel","onClick","context","readOnly","save","createCheckpoint","addToolbarButtonClass","ReactWidget","UseSignal","signal","fileChanged","ToolbarButtonComponent","icon","saveIcon","tooltip","enabled","contentsModel","writable","createInsertButton","ToolbarButton","addIcon","createCutButton","cutIcon","createCopyButton","copyIcon","createPasteButton","pasteIcon","createRunButton","runIcon","createRestartRunAllButton","dialogs","fastForwardIcon","sessionContextDialogs","restart","restarted","createCellTypeItem","CellTypeSwitcher","getDefaultItems","sessionDialogs","name","widget","Toolbar","super","this","handleChange","event","target","_notebook","handleKeyDown","keyCode","_trans","addClass","activeCellChanged","connect","selectionChanged","HTMLSelect","className","onChange","onKeyDown","CellList","modelDB","factory","_isDisposed","_changed","_factory","_cellOrder","createList","_cellMap","ObservableMap","changed","_onOrderChanged","arr","ArrayIterator","dispose","fromIndex","toIndex","newValues","startIndex","endIndex","removeRange","canRedo","canUndo","isUndoAble","delete","clearUndo","order","change","has","createValue","oldValues","oldIndex","newIndex","NotebookModel","DocumentModel","options","languagePreference","_nbformat","_nbformatMinor","defaultContentFactory","view","_cells","_onCellsChanged","createMap","_ensureMetadata","triggerContentChange","_deletedCells","spec","info","JSON","stringify","parse","create","nbformat_minor","nbformat","useId","pushAll","oldValue","newValue","origNbformat","orig_nbformat","triggerStateChange","msg","dirty","initialize","list","contentChanged","display_name","ContentFactory","codeCellContentFactory","CodeCellModel","opts","UUID","MarkdownCellModel","RawCellModel","NotebookModelFactory","_disposed","RankedPanel","Widget","_items","layout","PanelLayout","rank","rankItem","itemCmp","insertWidget","item","NotebookTools","_commonTools","_advancedTools","addWidget","Collapse","_tracker","tracker","currentChanged","_onActiveNotebookPanelChanged","_onActiveCellChanged","_onSelectionChanged","currentWidget","tool","section","notebookTools","MessageLoop","ActiveNotebookPanelMessage","ActiveCellMessage","_prevActiveNotebookModel","disconnect","_onActiveNotebookPanelMetadataChanged","activeNBModel","activeNotebookPanel","_toolChildren","_prevActiveCell","_onActiveCellMetadataChanged","SelectionMessage","sender","args","ObservableJSON","chain","children","ConflatableMessage","Tool","processMessage","onActiveNotebookPanelChanged","onActiveCellChanged","onSelectionChanged","onActiveCellMetadataChanged","onActiveNotebookPanelMetadataChanged","ActiveCellTool","_model","CodeEditor","count","_cellModel","_onValueChanged","mimeTypeChanged","_onMimeTypeChanged","promptNode","cloneNode","prompt","editorFactory","split","mimeType","editorWidget","CodeEditorWrapper","setOption","MetadataEditorTool","JSONEditor","titleNode","createElement","textContent","NotebookMetadataEditorTool","_update","nb","CellMetadataEditorTool","KeySelector","createSelectorNode","_getValue","_default","_setValue","_changeGuard","default","_validCellTypes","validCellTypes","_getter","getter","_setter","setter","getElementsByTagName","onValueChanged","selectNode","addEventListener","removeEventListener","disabled","cellType","indexOf","createSlideShowSelector","optionValueArray","slide_type","createNBConvertSelector","first","second","toLocaleUpperCase","optionNodes","option","h","VirtualDOM","Styling","NB_CELL_CLASS","EDIT_CLASS","COMMAND_CLASS","ACTIVE_CLASS","SELECTED_CLASS","OTHER_SELECTED_CLASS","DROP_TARGET_CLASS","DROP_SOURCE_CLASS","DRAG_IMAGE_CLASS","CELL_DRAG_CONTENT_CLASS","CELL_DRAG_PROMPT_CLASS","CELL_DRAG_MULTIPLE_BACK","StaticNotebook","_editorConfig","defaultEditorConfig","_notebookConfig","defaultNotebookConfig","_mimetype","_modelChanged","_modelContentChanged","dataset","rendermime","NotebookPanelLayout","_mimetypeService","mimeTypeService","isCollaborative","connected","collaborators","_onCollaboratorsChanged","_onModelChanged","onModelChanged","_updateEditorConfig","_updateNotebookConfig","_updateMimetype","onMetadataChanged","onModelContentChanged","_removeCell","_insertCell","_moveCell","requestAnimationFrame","_createCodeCell","_createMarkdownCell","_createRawCell","onCellInserted","updateEditorOnShow","syncCollapse","syncEditable","syncScrolled","onCellMoved","parent","onCellRemoved","getMimeTypeByLanguage","refresh","toggleClass","scrollPastEnd","lineWrap","matchBrackets","autoClosingBrackets","Cell","initializeState","RawCell","Notebook","processNotebookOptions","_activeCellIndex","_activeCell","_mode","_drag","_fragment","_dragData","_mouseMode","_activeCellChanged","_stateChanged","_selectionChanged","_checkCacheOnNextResize","tabIndex","setAttribute","_ensureFocus","focus","_trimSelections","selectedProperty","head","anchor","getContiguousSelection","c","isSelected","last","activeIndex","position","threshold","ar","delta","top","height","abs","scrollTop","fragment","ready","eventPhase","Event","CAPTURING_PHASE","_evtContextMenuCapture","_evtMouseDownCapture","_evtMouseDown","currentTarget","_evtDocumentMouseup","_evtDocumentMousemove","_evtDblClick","_evtFocusIn","_evtFocusOut","_evtDragEnter","_evtDragLeave","_evtDragOver","_evtDrop","onAfterAttach","onResize","cache","_cellLayoutStateCache","width","parseInt","style","w","removeClass","el","querySelector","error","console","warn","scrollIntoView","localCollaborator","uuid","sessionId","selectionStyle","color","edgeRequested","_onEdgeRequest","location","prev","lastLine","lineCount","setCursorPosition","line","column","force","hasFocus","n","classList","parentElement","_findCell","elementFromPoint","clientX","clientY","shiftKey","_findEventTargetAndCell","preventDefault","targetArea","hasSelection","window","getSelection","e","pressX","pressY","stopPropagation","dx","dy","_startDrag","mimeData","add","elements","getElementsByClassName","dropAction","proposedAction","toMove","cellWidget","countString","dragImage","createDragImage","Drag","MimeData","supportedActions","action","relatedTarget","localName","toggle","AttachedProperty","promptNumber","cellContent","NotebookPanel","DocumentWidget","_autorestarting","toolbar","kernelChanged","_onKernelChanged","statusChanged","_onSessionStatusChanged","saveState","_onSave","revealed","includes","kernelPreference","shutdownOnDispose","kernelShutdown","setFragment","Printing","async","PageConfig","format","download","kernel","_updateLanguage","language_info","_updateSpec","language","IContentFactory","Token","NotebookTracker","WidgetTracker","arguments","NotebookWidgetFactory","ABCWidgetFactory","_sessionDialogs","nbOptions","resolver","urlResolver","createNotebook","CommandEditComponent","props","TextItem","Text","notebookMode","CommandEditStatus","VDomRenderer","Model","NotebookTrustComponent","allCellsTrusted","trustedIcon","stylesheet","notTrustedIcon","VDomModel","_onChanged","oldMode","_notebookMode","_triggerChange","oldNotebook","stateChanged","modelContentChanged","oldState","newState","NotebookTrustStatus","trustedCells","totalCells","activeCellTrusted","cellTrust","_trustedCells","_totalCells","_activeCellTrusted","_getAllState","total","_deriveCellTrustState","reduce","accum","current","INotebookWidgetFactory","INotebookTools","INotebookTracker"],"mappings":"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","file":"8383.bundle.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Clipboard, Dialog, showDialog } from '@jupyterlab/apputils';\nimport { CodeCell, MarkdownCell, isMarkdownCellModel, isRawCellModel, isCodeCellModel } from '@jupyterlab/cells';\nimport { ArrayExt, each, toArray } from '@lumino/algorithm';\nimport { JSONExt } from '@lumino/coreutils';\nimport { ElementExt } from '@lumino/domutils';\nimport { Signal } from '@lumino/signaling';\nimport * as React from 'react';\nimport { nullTranslator } from '@jupyterlab/translation';\n/**\n * The mimetype used for Jupyter cell data.\n */\nconst JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';\n/**\n * A collection of actions that run against notebooks.\n *\n * #### Notes\n * All of the actions are a no-op if there is no model on the notebook.\n * The actions set the widget `mode` to `'command'` unless otherwise specified.\n * The actions will preserve the selection on the notebook widget unless\n * otherwise specified.\n */\nexport class NotebookActions {\n    /**\n     * A signal that emits whenever a cell is run.\n     */\n    static get executed() {\n        return Private.executed;\n    }\n    /**\n     * A private constructor for the `NotebookActions` class.\n     *\n     * #### Notes\n     * This class can never be instantiated. Its static member `executed` will be\n     * merged with the `NotebookActions` namespace. The reason it exists as a\n     * standalone class is because at run time, the `Private.executed` variable\n     * does not yet exist, so it needs to be referenced via a getter.\n     */\n    constructor() {\n        // Intentionally empty.\n    }\n}\n/**\n * A namespace for `NotebookActions` static methods.\n */\n(function (NotebookActions) {\n    /**\n     * Split the active cell into two or more cells.\n     *\n     * @param widget - The target notebook widget.\n     *\n     * #### Notes\n     * It will preserve the existing mode.\n     * The last cell will be activated.\n     * The existing selection will be cleared.\n     * The leading whitespace in the second cell will be removed.\n     * If there is no content, two empty cells will be created.\n     * Both cells will have the same type as the original cell.\n     * This action can be undone.\n     */\n    function splitCell(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.deselectAll();\n        const nbModel = notebook.model;\n        const index = notebook.activeCellIndex;\n        const child = notebook.widgets[index];\n        const editor = child.editor;\n        const selections = editor.getSelections();\n        const orig = child.model.value.text;\n        const offsets = [0];\n        for (let i = 0; i < selections.length; i++) {\n            // append start and end to handle selections\n            // cursors will have same start and end\n            const start = editor.getOffsetAt(selections[i].start);\n            const end = editor.getOffsetAt(selections[i].end);\n            if (start < end) {\n                offsets.push(start);\n                offsets.push(end);\n            }\n            else if (end < start) {\n                offsets.push(end);\n                offsets.push(start);\n            }\n            else {\n                offsets.push(start);\n            }\n        }\n        offsets.push(orig.length);\n        const clones = [];\n        for (let i = 0; i + 1 < offsets.length; i++) {\n            const clone = Private.cloneCell(nbModel, child.model);\n            clones.push(clone);\n        }\n        for (let i = 0; i < clones.length; i++) {\n            if (i !== clones.length - 1 && clones[i].type === 'code') {\n                clones[i].outputs.clear();\n            }\n            clones[i].value.text = orig\n                .slice(offsets[i], offsets[i + 1])\n                .replace(/^\\n+/, '')\n                .replace(/\\n+$/, '');\n        }\n        const cells = nbModel.cells;\n        cells.beginCompoundOperation();\n        for (let i = 0; i < clones.length; i++) {\n            if (i === 0) {\n                cells.set(index, clones[i]);\n            }\n            else {\n                cells.insert(index + i, clones[i]);\n            }\n        }\n        cells.endCompoundOperation();\n        notebook.activeCellIndex = index + clones.length - 1;\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.splitCell = splitCell;\n    /**\n     * Merge the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * If only one cell is selected, the next cell will be selected.\n     * If the active cell is a code cell, its outputs will be cleared.\n     * This action can be undone.\n     * The final cell will have the same type as the active cell.\n     * If the active cell is a markdown cell, it will be unrendered.\n     */\n    function mergeCells(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const toMerge = [];\n        const toDelete = [];\n        const model = notebook.model;\n        const cells = model.cells;\n        const primary = notebook.activeCell;\n        const active = notebook.activeCellIndex;\n        const attachments = {};\n        // Get the cells to merge.\n        notebook.widgets.forEach((child, index) => {\n            if (notebook.isSelectedOrActive(child)) {\n                toMerge.push(child.model.value.text);\n                if (index !== active) {\n                    toDelete.push(child.model);\n                }\n                // Collect attachments if the cell is a markdown cell or a raw cell\n                const model = child.model;\n                if (isRawCellModel(model) || isMarkdownCellModel(model)) {\n                    for (const key of model.attachments.keys) {\n                        attachments[key] = model.attachments.get(key).toJSON();\n                    }\n                }\n            }\n        });\n        // Check for only a single cell selected.\n        if (toMerge.length === 1) {\n            // Bail if it is the last cell.\n            if (active === cells.length - 1) {\n                return;\n            }\n            // Otherwise merge with the next cell.\n            const cellModel = cells.get(active + 1);\n            toMerge.push(cellModel.value.text);\n            toDelete.push(cellModel);\n        }\n        notebook.deselectAll();\n        // Create a new cell for the source to preserve history.\n        const newModel = Private.cloneCell(model, primary.model);\n        newModel.value.text = toMerge.join('\\n\\n');\n        if (isCodeCellModel(newModel)) {\n            newModel.outputs.clear();\n        }\n        else if (isMarkdownCellModel(newModel) || isRawCellModel(newModel)) {\n            newModel.attachments.fromJSON(attachments);\n        }\n        // Make the changes while preserving history.\n        cells.beginCompoundOperation();\n        cells.set(active, newModel);\n        toDelete.forEach(cell => {\n            cells.removeValue(cell);\n        });\n        cells.endCompoundOperation();\n        // If the original cell is a markdown cell, make sure\n        // the new cell is unrendered.\n        if (primary instanceof MarkdownCell) {\n            notebook.activeCell.rendered = false;\n        }\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.mergeCells = mergeCells;\n    /**\n     * Delete the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The cell after the last selected cell will be activated.\n     * It will add a code cell if all cells are deleted.\n     * This action can be undone.\n     */\n    function deleteCells(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        Private.deleteCells(notebook);\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.deleteCells = deleteCells;\n    /**\n     * Insert a new code cell above the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * The new cell will the active cell.\n     */\n    function insertAbove(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const model = notebook.model;\n        const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});\n        const active = notebook.activeCellIndex;\n        model.cells.insert(active, cell);\n        // Make the newly inserted cell active.\n        notebook.activeCellIndex = active;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.insertAbove = insertAbove;\n    /**\n     * Insert a new code cell below the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * The new cell will be the active cell.\n     */\n    function insertBelow(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const model = notebook.model;\n        const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});\n        model.cells.insert(notebook.activeCellIndex + 1, cell);\n        // Make the newly inserted cell active.\n        notebook.activeCellIndex++;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.insertBelow = insertBelow;\n    /**\n     * Move the selected cell(s) down.\n     *\n     * @param notebook = The target notebook widget.\n     */\n    function moveDown(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const cells = notebook.model.cells;\n        const widgets = notebook.widgets;\n        cells.beginCompoundOperation();\n        for (let i = cells.length - 2; i > -1; i--) {\n            if (notebook.isSelectedOrActive(widgets[i])) {\n                if (!notebook.isSelectedOrActive(widgets[i + 1])) {\n                    cells.move(i, i + 1);\n                    if (notebook.activeCellIndex === i) {\n                        notebook.activeCellIndex++;\n                    }\n                    notebook.select(widgets[i + 1]);\n                    notebook.deselect(widgets[i]);\n                }\n            }\n        }\n        cells.endCompoundOperation();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.moveDown = moveDown;\n    /**\n     * Move the selected cell(s) up.\n     *\n     * @param widget - The target notebook widget.\n     */\n    function moveUp(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const cells = notebook.model.cells;\n        const widgets = notebook.widgets;\n        cells.beginCompoundOperation();\n        for (let i = 1; i < cells.length; i++) {\n            if (notebook.isSelectedOrActive(widgets[i])) {\n                if (!notebook.isSelectedOrActive(widgets[i - 1])) {\n                    cells.move(i, i - 1);\n                    if (notebook.activeCellIndex === i) {\n                        notebook.activeCellIndex--;\n                    }\n                    notebook.select(widgets[i - 1]);\n                    notebook.deselect(widgets[i]);\n                }\n            }\n        }\n        cells.endCompoundOperation();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.moveUp = moveUp;\n    /**\n     * Change the selected cell type(s).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param value - The target cell type.\n     *\n     * #### Notes\n     * It should preserve the widget mode.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * Any cells converted to markdown will be unrendered.\n     */\n    function changeCellType(notebook, value) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        Private.changeCellType(notebook, value);\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.changeCellType = changeCellType;\n    /**\n     * Run the selected cell(s).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The last selected cell will be activated, but not scrolled into view.\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     */\n    function run(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext);\n        Private.handleRunState(notebook, state, false);\n        return promise;\n    }\n    NotebookActions.run = run;\n    /**\n     * Run the selected cell(s) and advance to the next cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * The cell after the last selected cell will be activated and scrolled into view.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * If the last selected cell is the last cell, a new code cell\n     * will be created in `'edit'` mode.  The new cell creation can be undone.\n     */\n    function runAndAdvance(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext);\n        const model = notebook.model;\n        if (notebook.activeCellIndex === notebook.widgets.length - 1) {\n            const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});\n            model.cells.push(cell);\n            notebook.activeCellIndex++;\n            notebook.mode = 'edit';\n        }\n        else {\n            notebook.activeCellIndex++;\n        }\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAndAdvance = runAndAdvance;\n    /**\n     * Run the selected cell(s) and insert a new code cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The widget mode will be set to `'edit'` after running.\n     * The existing selection will be cleared.\n     * The cell insert can be undone.\n     * The new cell will be scrolled into view.\n     */\n    function runAndInsert(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext);\n        const model = notebook.model;\n        const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});\n        model.cells.insert(notebook.activeCellIndex + 1, cell);\n        notebook.activeCellIndex++;\n        notebook.mode = 'edit';\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAndInsert = runAndInsert;\n    /**\n     * Run all of the cells in the notebook.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The last cell in the notebook will be activated and scrolled into view.\n     */\n    function runAll(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(child => {\n            notebook.select(child);\n        });\n        const promise = Private.runSelected(notebook, sessionContext);\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAll = runAll;\n    function renderAllMarkdown(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const previousIndex = notebook.activeCellIndex;\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach((child, index) => {\n            if (child.model.type === 'markdown') {\n                notebook.select(child);\n                // This is to make sure that the activeCell\n                // does not get executed\n                notebook.activeCellIndex = index;\n            }\n        });\n        if (notebook.activeCell.model.type !== 'markdown') {\n            return Promise.resolve(true);\n        }\n        const promise = Private.runSelected(notebook, sessionContext);\n        notebook.activeCellIndex = previousIndex;\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.renderAllMarkdown = renderAllMarkdown;\n    /**\n     * Run all of the cells before the currently active cell (exclusive).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The currently active cell will remain selected.\n     */\n    function runAllAbove(notebook, sessionContext) {\n        const { activeCell, activeCellIndex, model } = notebook;\n        if (!model || !activeCell || activeCellIndex < 1) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        notebook.activeCellIndex--;\n        notebook.deselectAll();\n        for (let i = 0; i < notebook.activeCellIndex; ++i) {\n            notebook.select(notebook.widgets[i]);\n        }\n        const promise = Private.runSelected(notebook, sessionContext);\n        notebook.activeCellIndex++;\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAllAbove = runAllAbove;\n    /**\n     * Run all of the cells after the currently active cell (inclusive).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The last cell in the notebook will be activated and scrolled into view.\n     */\n    function runAllBelow(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        notebook.deselectAll();\n        for (let i = notebook.activeCellIndex; i < notebook.widgets.length; ++i) {\n            notebook.select(notebook.widgets[i]);\n        }\n        const promise = Private.runSelected(notebook, sessionContext);\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAllBelow = runAllBelow;\n    /**\n     * Replaces the selection in the active cell of the notebook.\n     *\n     * @param notebook - The target notebook widget.\n     * @param text - The text to replace the selection.\n     */\n    function replaceSelection(notebook, text) {\n        var _a, _b;\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        (_b = (_a = notebook.activeCell.editor).replaceSelection) === null || _b === void 0 ? void 0 : _b.call(_a, text);\n    }\n    NotebookActions.replaceSelection = replaceSelection;\n    /**\n     * Select the above the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This is a no-op if the first cell is the active cell.\n     * This will skip any collapsed cells.\n     * The existing selection will be cleared.\n     */\n    function selectAbove(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        if (notebook.activeCellIndex === 0) {\n            return;\n        }\n        let possibleNextCell = notebook.activeCellIndex - 1;\n        // find first non hidden cell above current cell\n        if (notebook.mode === 'edit') {\n            while (notebook.widgets[possibleNextCell].inputHidden) {\n                // If we are at the top cell, we cannot change selection.\n                if (possibleNextCell === 0) {\n                    return;\n                }\n                possibleNextCell -= 1;\n            }\n        }\n        const state = Private.getState(notebook);\n        notebook.activeCellIndex = possibleNextCell;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.selectAbove = selectAbove;\n    /**\n     * Select the cell below the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This is a no-op if the last cell is the active cell.\n     * This will skip any collapsed cells.\n     * The existing selection will be cleared.\n     */\n    function selectBelow(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const maxCellIndex = notebook.widgets.length - 1;\n        if (notebook.activeCellIndex === maxCellIndex) {\n            return;\n        }\n        let possibleNextCell = notebook.activeCellIndex + 1;\n        // find first non hidden cell below current cell\n        if (notebook.mode === 'edit') {\n            while (notebook.widgets[possibleNextCell].inputHidden) {\n                // If we are at the bottom cell, we cannot change selection.\n                if (possibleNextCell === maxCellIndex) {\n                    return;\n                }\n                possibleNextCell += 1;\n            }\n        }\n        const state = Private.getState(notebook);\n        notebook.activeCellIndex = possibleNextCell;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.selectBelow = selectBelow;\n    /**\n     * Extend the selection to the cell above.\n     *\n     * @param notebook - The target notebook widget.\n     * @param toTop - If true, denotes selection to extend to the top.\n     *\n     * #### Notes\n     * This is a no-op if the first cell is the active cell.\n     * The new cell will be activated.\n     */\n    function extendSelectionAbove(notebook, toTop = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        // Do not wrap around.\n        if (notebook.activeCellIndex === 0) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        // Check if toTop is true, if yes, selection is made to the top.\n        if (toTop) {\n            notebook.extendContiguousSelectionTo(0);\n        }\n        else {\n            notebook.extendContiguousSelectionTo(notebook.activeCellIndex - 1);\n        }\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.extendSelectionAbove = extendSelectionAbove;\n    /**\n     * Extend the selection to the cell below.\n     *\n     * @param notebook - The target notebook widget.\n     * @param toBottom - If true, denotes selection to extend to the bottom.\n     *\n     * #### Notes\n     * This is a no-op if the last cell is the active cell.\n     * The new cell will be activated.\n     */\n    function extendSelectionBelow(notebook, toBottom = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        // Do not wrap around.\n        if (notebook.activeCellIndex === notebook.widgets.length - 1) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        // Check if toBottom is true, if yes selection is made to the bottom.\n        if (toBottom) {\n            notebook.extendContiguousSelectionTo(notebook.widgets.length - 1);\n        }\n        else {\n            notebook.extendContiguousSelectionTo(notebook.activeCellIndex + 1);\n        }\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.extendSelectionBelow = extendSelectionBelow;\n    /**\n     * Select all of the cells of the notebook.\n     *\n     * @param notebook - the target notebook widget.\n     */\n    function selectAll(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        notebook.widgets.forEach(child => {\n            notebook.select(child);\n        });\n    }\n    NotebookActions.selectAll = selectAll;\n    /**\n     * Deselect all of the cells of the notebook.\n     *\n     * @param notebook - the targe notebook widget.\n     */\n    function deselectAll(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        notebook.deselectAll();\n    }\n    NotebookActions.deselectAll = deselectAll;\n    /**\n     * Copy the selected cell data to a clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function copy(notebook) {\n        Private.copyOrCut(notebook, false);\n    }\n    NotebookActions.copy = copy;\n    /**\n     * Cut the selected cell data to a clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * This action can be undone.\n     * A new code cell is added if all cells are cut.\n     */\n    function cut(notebook) {\n        Private.copyOrCut(notebook, true);\n    }\n    NotebookActions.cut = cut;\n    /**\n     * Paste cells from the application clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param mode - the mode of the paste operation: 'below' pastes cells\n     *   below the active cell, 'above' pastes cells above the active cell,\n     *   and 'replace' removes the currently selected cells and pastes cells\n     *   in their place.\n     *\n     * #### Notes\n     * The last pasted cell becomes the active cell.\n     * This is a no-op if there is no cell data on the clipboard.\n     * This action can be undone.\n     */\n    function paste(notebook, mode = 'below') {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const clipboard = Clipboard.getInstance();\n        if (!clipboard.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const values = clipboard.getData(JUPYTER_CELL_MIME);\n        const model = notebook.model;\n        notebook.mode = 'command';\n        const newCells = values.map(cell => {\n            switch (cell.cell_type) {\n                case 'code':\n                    return model.contentFactory.createCodeCell({ cell });\n                case 'markdown':\n                    return model.contentFactory.createMarkdownCell({ cell });\n                default:\n                    return model.contentFactory.createRawCell({ cell });\n            }\n        });\n        const cells = notebook.model.cells;\n        let index;\n        cells.beginCompoundOperation();\n        // Set the starting index of the paste operation depending upon the mode.\n        switch (mode) {\n            case 'below':\n                index = notebook.activeCellIndex;\n                break;\n            case 'above':\n                index = notebook.activeCellIndex - 1;\n                break;\n            case 'replace': {\n                // Find the cells to delete.\n                const toDelete = [];\n                notebook.widgets.forEach((child, index) => {\n                    const deletable = child.model.metadata.get('deletable') !== false;\n                    if (notebook.isSelectedOrActive(child) && deletable) {\n                        toDelete.push(index);\n                    }\n                });\n                // If cells are not deletable, we may not have anything to delete.\n                if (toDelete.length > 0) {\n                    // Delete the cells as one undo event.\n                    toDelete.reverse().forEach(i => {\n                        cells.remove(i);\n                    });\n                }\n                index = toDelete[0];\n                break;\n            }\n            default:\n                break;\n        }\n        newCells.forEach(cell => {\n            cells.insert(++index, cell);\n        });\n        cells.endCompoundOperation();\n        notebook.activeCellIndex += newCells.length;\n        notebook.deselectAll();\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.paste = paste;\n    /**\n     * Undo a cell action.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * This is a no-op if if there are no cell actions to undo.\n     */\n    function undo(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        notebook.model.cells.undo();\n        notebook.deselectAll();\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.undo = undo;\n    /**\n     * Redo a cell action.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * This is a no-op if there are no cell actions to redo.\n     */\n    function redo(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        notebook.model.cells.redo();\n        notebook.deselectAll();\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.redo = redo;\n    /**\n     * Toggle the line number of all cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The original state is based on the state of the active cell.\n     * The `mode` of the widget will be preserved.\n     */\n    function toggleAllLineNumbers(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const config = notebook.editorConfig;\n        const lineNumbers = !(config.code.lineNumbers &&\n            config.markdown.lineNumbers &&\n            config.raw.lineNumbers);\n        const newConfig = {\n            code: Object.assign(Object.assign({}, config.code), { lineNumbers }),\n            markdown: Object.assign(Object.assign({}, config.markdown), { lineNumbers }),\n            raw: Object.assign(Object.assign({}, config.raw), { lineNumbers })\n        };\n        notebook.editorConfig = newConfig;\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.toggleAllLineNumbers = toggleAllLineNumbers;\n    /**\n     * Clear the code outputs of the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget `mode` will be preserved.\n     */\n    function clearOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        each(notebook.model.cells, (cell, index) => {\n            const child = notebook.widgets[index];\n            if (notebook.isSelectedOrActive(child) && cell.type === 'code') {\n                cell.clearExecution();\n                child.outputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.clearOutputs = clearOutputs;\n    /**\n     * Clear all the code outputs on the widget.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget `mode` will be preserved.\n     */\n    function clearAllOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        each(notebook.model.cells, (cell, index) => {\n            const child = notebook.widgets[index];\n            if (cell.type === 'code') {\n                cell.clearExecution();\n                child.outputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.clearAllOutputs = clearAllOutputs;\n    /**\n     * Hide the code on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.inputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.hideCode = hideCode;\n    /**\n     * Show the code on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function showCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.inputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showCode = showCode;\n    /**\n     * Hide the code on all code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideAllCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.inputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.hideAllCode = hideAllCode;\n    /**\n     * Show the code on all code cells.\n     *\n     * @param widget - The target notebook widget.\n     */\n    function showAllCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.inputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showAllCode = showAllCode;\n    /**\n     * Hide the output on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideOutput(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.hideOutput = hideOutput;\n    /**\n     * Show the output on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function showOutput(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showOutput = showOutput;\n    /**\n     * Hide the output on all code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideAllOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.outputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.hideAllOutputs = hideAllOutputs;\n    /**\n     * Show the output on all code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function showAllOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.outputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showAllOutputs = showAllOutputs;\n    /**\n     * Enable output scrolling for all selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function enableOutputScrolling(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputsScrolled = true;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.enableOutputScrolling = enableOutputScrolling;\n    /**\n     * Disable output scrolling for all selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function disableOutputScrolling(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputsScrolled = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.disableOutputScrolling = disableOutputScrolling;\n    /**\n     * Go to the last cell that is run or current if it is running.\n     *\n     * Note: This requires execution timing to be toggled on or this will have\n     * no effect.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function selectLastRunCell(notebook) {\n        let latestTime = null;\n        let latestCellIdx = null;\n        notebook.widgets.forEach((cell, cellIndx) => {\n            if (cell.model.type === 'code') {\n                const execution = cell.model.metadata.get('execution');\n                if (execution &&\n                    JSONExt.isObject(execution) &&\n                    execution['iopub.status.busy'] !== undefined) {\n                    // The busy status is used as soon as a request is received:\n                    // https://jupyter-client.readthedocs.io/en/stable/messaging.html\n                    const timestamp = execution['iopub.status.busy'].toString();\n                    if (timestamp) {\n                        const startTime = new Date(timestamp);\n                        if (!latestTime || startTime >= latestTime) {\n                            latestTime = startTime;\n                            latestCellIdx = cellIndx;\n                        }\n                    }\n                }\n            }\n        });\n        if (latestCellIdx !== null) {\n            notebook.activeCellIndex = latestCellIdx;\n        }\n    }\n    NotebookActions.selectLastRunCell = selectLastRunCell;\n    /**\n     * Set the markdown header level.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param level - The header level.\n     *\n     * #### Notes\n     * All selected cells will be switched to markdown.\n     * The level will be clamped between 1 and 6.\n     * If there is an existing header, it will be replaced.\n     * There will always be one blank space after the header.\n     * The cells will be unrendered.\n     */\n    function setMarkdownHeader(notebook, level) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const cells = notebook.model.cells;\n        level = Math.min(Math.max(level, 1), 6);\n        notebook.widgets.forEach((child, index) => {\n            if (notebook.isSelectedOrActive(child)) {\n                Private.setMarkdownHeader(cells.get(index), level);\n            }\n        });\n        Private.changeCellType(notebook, 'markdown');\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.setMarkdownHeader = setMarkdownHeader;\n    /**\n     * Trust the notebook after prompting the user.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @returns a promise that resolves when the transaction is finished.\n     *\n     * #### Notes\n     * No dialog will be presented if the notebook is already trusted.\n     */\n    function trust(notebook, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        if (!notebook.model) {\n            return Promise.resolve();\n        }\n        // Do nothing if already trusted.\n        const cells = toArray(notebook.model.cells);\n        const trusted = cells.every(cell => cell.trusted);\n        // FIXME\n        const trustMessage = (React.createElement(\"p\", null,\n            trans.__('A trusted Jupyter notebook may execute hidden malicious code when you openit.'),\n            React.createElement(\"br\", null),\n            trans.__('Selecting trust will re-render this notebook in a trusted state.'),\n            React.createElement(\"br\", null),\n            trans.__('For more information, see the <a href=\"https://jupyter-server.readthedocs.io/en/stable/operators/security.html\">%1</a>', trans.__('Jupyter security documentation'))));\n        if (trusted) {\n            return showDialog({\n                body: trans.__('Notebook is already trusted'),\n                buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n            }).then(() => undefined);\n        }\n        return showDialog({\n            body: trustMessage,\n            title: trans.__('Trust this notebook?'),\n            buttons: [\n                Dialog.cancelButton({ label: trans.__('Cancel') }),\n                Dialog.warnButton({ label: trans.__('Ok') })\n            ] // FIXME?\n        }).then(result => {\n            if (result.button.accept) {\n                cells.forEach(cell => {\n                    cell.trusted = true;\n                });\n            }\n        });\n    }\n    NotebookActions.trust = trust;\n})(NotebookActions || (NotebookActions = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A signal that emits whenever a cell is run.\n     */\n    Private.executed = new Signal({});\n    /**\n     * Get the state of a widget before running an action.\n     */\n    function getState(notebook) {\n        return {\n            wasFocused: notebook.node.contains(document.activeElement),\n            activeCell: notebook.activeCell\n        };\n    }\n    Private.getState = getState;\n    /**\n     * Handle the state of a widget after running an action.\n     */\n    function handleState(notebook, state, scrollIfNeeded = false) {\n        const { activeCell, node } = notebook;\n        if (state.wasFocused || notebook.mode === 'edit') {\n            notebook.activate();\n        }\n        if (scrollIfNeeded && activeCell) {\n            ElementExt.scrollIntoViewIfNeeded(node, activeCell.node);\n        }\n    }\n    Private.handleState = handleState;\n    /**\n     * Handle the state of a widget after running a run action.\n     */\n    function handleRunState(notebook, state, scroll = false) {\n        if (state.wasFocused || notebook.mode === 'edit') {\n            notebook.activate();\n        }\n        if (scroll && state.activeCell) {\n            // Scroll to the top of the previous active cell output.\n            const rect = state.activeCell.inputArea.node.getBoundingClientRect();\n            notebook.scrollToPosition(rect.bottom, 45);\n        }\n    }\n    Private.handleRunState = handleRunState;\n    /**\n     * Clone a cell model.\n     */\n    function cloneCell(model, cell) {\n        switch (cell.type) {\n            case 'code':\n                // TODO why isn't modeldb or id passed here?\n                return model.contentFactory.createCodeCell({ cell: cell.toJSON() });\n            case 'markdown':\n                // TODO why isn't modeldb or id passed here?\n                return model.contentFactory.createMarkdownCell({ cell: cell.toJSON() });\n            default:\n                // TODO why isn't modeldb or id passed here?\n                return model.contentFactory.createRawCell({ cell: cell.toJSON() });\n        }\n    }\n    Private.cloneCell = cloneCell;\n    /**\n     * Run the selected cells.\n     */\n    function runSelected(notebook, sessionContext) {\n        notebook.mode = 'command';\n        let lastIndex = notebook.activeCellIndex;\n        const selected = notebook.widgets.filter((child, index) => {\n            const active = notebook.isSelectedOrActive(child);\n            if (active) {\n                lastIndex = index;\n            }\n            return active;\n        });\n        notebook.activeCellIndex = lastIndex;\n        notebook.deselectAll();\n        return Promise.all(selected.map(child => runCell(notebook, child, sessionContext)))\n            .then(results => {\n            if (notebook.isDisposed) {\n                return false;\n            }\n            // Post an update request.\n            notebook.update();\n            return results.every(result => result);\n        })\n            .catch(reason => {\n            if (reason.message === 'KernelReplyNotOK') {\n                selected.map(cell => {\n                    // Remove '*' prompt from cells that didn't execute\n                    if (cell.model.type === 'code' &&\n                        cell.model.executionCount == null) {\n                        cell.setPrompt('');\n                    }\n                });\n            }\n            else {\n                throw reason;\n            }\n            notebook.update();\n            return false;\n        });\n    }\n    Private.runSelected = runSelected;\n    /**\n     * Run a cell.\n     */\n    function runCell(notebook, cell, sessionContext, translator) {\n        var _a, _b, _c;\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        switch (cell.model.type) {\n            case 'markdown':\n                cell.rendered = true;\n                cell.inputHidden = false;\n                Private.executed.emit({ notebook, cell });\n                break;\n            case 'code':\n                if (sessionContext) {\n                    if (sessionContext.isTerminating) {\n                        void showDialog({\n                            title: trans.__('Kernel Terminating'),\n                            body: trans.__('The kernel for %1 appears to be terminating. You can not run any cell for now.', (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.path),\n                            buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n                        });\n                        break;\n                    }\n                    const deletedCells = (_c = (_b = notebook.model) === null || _b === void 0 ? void 0 : _b.deletedCells) !== null && _c !== void 0 ? _c : [];\n                    return CodeCell.execute(cell, sessionContext, {\n                        deletedCells,\n                        recordTiming: notebook.notebookConfig.recordTiming\n                    })\n                        .then(reply => {\n                        deletedCells.splice(0, deletedCells.length);\n                        if (cell.isDisposed) {\n                            return false;\n                        }\n                        if (!reply) {\n                            return true;\n                        }\n                        if (reply.content.status === 'ok') {\n                            const content = reply.content;\n                            if (content.payload && content.payload.length) {\n                                handlePayload(content, notebook, cell);\n                            }\n                            return true;\n                        }\n                        else {\n                            throw new Error('KernelReplyNotOK');\n                        }\n                    })\n                        .catch(reason => {\n                        if (cell.isDisposed || reason.message.startsWith('Canceled')) {\n                            return false;\n                        }\n                        throw reason;\n                    })\n                        .then(ran => {\n                        if (ran) {\n                            Private.executed.emit({ notebook, cell });\n                        }\n                        return ran;\n                    });\n                }\n                cell.model.clearExecution();\n                break;\n            default:\n                break;\n        }\n        return Promise.resolve(true);\n    }\n    /**\n     * Handle payloads from an execute reply.\n     *\n     * #### Notes\n     * Payloads are deprecated and there are no official interfaces for them in\n     * the kernel type definitions.\n     * See [Payloads (DEPRECATED)](https://jupyter-client.readthedocs.io/en/latest/messaging.html#payloads-deprecated).\n     */\n    function handlePayload(content, notebook, cell) {\n        var _a;\n        const setNextInput = (_a = content.payload) === null || _a === void 0 ? void 0 : _a.filter(i => {\n            return i.source === 'set_next_input';\n        })[0];\n        if (!setNextInput) {\n            return;\n        }\n        const text = setNextInput.text;\n        const replace = setNextInput.replace;\n        if (replace) {\n            cell.model.value.text = text;\n            return;\n        }\n        // Create a new code cell and add as the next cell.\n        const newCell = notebook.model.contentFactory.createCodeCell({});\n        const cells = notebook.model.cells;\n        const index = ArrayExt.firstIndexOf(toArray(cells), cell.model);\n        newCell.value.text = text;\n        if (index === -1) {\n            cells.push(newCell);\n        }\n        else {\n            cells.insert(index + 1, newCell);\n        }\n    }\n    /**\n     * Copy or cut the selected cell data to the application clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param cut - Whether to copy or cut.\n     */\n    function copyOrCut(notebook, cut) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = getState(notebook);\n        const clipboard = Clipboard.getInstance();\n        notebook.mode = 'command';\n        clipboard.clear();\n        const data = notebook.widgets\n            .filter(cell => notebook.isSelectedOrActive(cell))\n            .map(cell => cell.model.toJSON())\n            .map(cellJSON => {\n            if (cellJSON.metadata.deletable !== undefined) {\n                delete cellJSON.metadata.deletable;\n            }\n            return cellJSON;\n        });\n        clipboard.setData(JUPYTER_CELL_MIME, data);\n        if (cut) {\n            deleteCells(notebook);\n        }\n        else {\n            notebook.deselectAll();\n        }\n        handleState(notebook, state);\n    }\n    Private.copyOrCut = copyOrCut;\n    /**\n     * Change the selected cell type(s).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param value - The target cell type.\n     *\n     * #### Notes\n     * It should preserve the widget mode.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * Any cells converted to markdown will be unrendered.\n     */\n    function changeCellType(notebook, value) {\n        const model = notebook.model;\n        const cells = model.cells;\n        cells.beginCompoundOperation();\n        notebook.widgets.forEach((child, index) => {\n            if (!notebook.isSelectedOrActive(child)) {\n                return;\n            }\n            if (child.model.type !== value) {\n                const cell = child.model.toJSON();\n                let newCell;\n                switch (value) {\n                    case 'code':\n                        newCell = model.contentFactory.createCodeCell({ cell });\n                        break;\n                    case 'markdown':\n                        newCell = model.contentFactory.createMarkdownCell({ cell });\n                        if (child.model.type === 'code') {\n                            newCell.trusted = false;\n                        }\n                        break;\n                    default:\n                        newCell = model.contentFactory.createRawCell({ cell });\n                        if (child.model.type === 'code') {\n                            newCell.trusted = false;\n                        }\n                }\n                cells.set(index, newCell);\n            }\n            if (value === 'markdown') {\n                // Fetch the new widget and unrender it.\n                child = notebook.widgets[index];\n                child.rendered = false;\n            }\n        });\n        cells.endCompoundOperation();\n        notebook.deselectAll();\n    }\n    Private.changeCellType = changeCellType;\n    /**\n     * Delete the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The cell after the last selected cell will be activated.\n     * If the last cell is deleted, then the previous one will be activated.\n     * It will add a code cell if all cells are deleted.\n     * This action can be undone.\n     */\n    function deleteCells(notebook) {\n        const model = notebook.model;\n        const cells = model.cells;\n        const toDelete = [];\n        notebook.mode = 'command';\n        // Find the cells to delete.\n        notebook.widgets.forEach((child, index) => {\n            const deletable = child.model.metadata.get('deletable') !== false;\n            if (notebook.isSelectedOrActive(child) && deletable) {\n                toDelete.push(index);\n                model.deletedCells.push(child.model.id);\n            }\n        });\n        // If cells are not deletable, we may not have anything to delete.\n        if (toDelete.length > 0) {\n            // Delete the cells as one undo event.\n            cells.beginCompoundOperation();\n            // Delete cells in reverse order to maintain the correct indices.\n            toDelete.reverse().forEach(index => {\n                cells.remove(index);\n            });\n            // Add a new cell if the notebook is empty. This is done\n            // within the compound operation to make the deletion of\n            // a notebook's last cell undoable.\n            if (!cells.length) {\n                cells.push(model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {}));\n            }\n            cells.endCompoundOperation();\n            // Select the *first* interior cell not deleted or the cell\n            // *after* the last selected cell.\n            // Note: The activeCellIndex is clamped to the available cells,\n            // so if the last cell is deleted the previous cell will be activated.\n            // The *first* index is the index of the last cell in the initial\n            // toDelete list due to the `reverse` operation above.\n            notebook.activeCellIndex = toDelete[0] - toDelete.length + 1;\n        }\n        // Deselect any remaining, undeletable cells. Do this even if we don't\n        // delete anything so that users are aware *something* happened.\n        notebook.deselectAll();\n    }\n    Private.deleteCells = deleteCells;\n    /**\n     * Set the markdown header level of a cell.\n     */\n    function setMarkdownHeader(cell, level) {\n        // Remove existing header or leading white space.\n        let source = cell.value.text;\n        const regex = /^(#+\\s*)|^(\\s*)/;\n        const newHeader = Array(level + 1).join('#') + ' ';\n        const matches = regex.exec(source);\n        if (matches) {\n            source = source.slice(matches[0].length);\n        }\n        cell.value.text = newHeader + source;\n    }\n    Private.setMarkdownHeader = setMarkdownHeader;\n})(Private || (Private = {}));\n//# sourceMappingURL=actions.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport * as React from 'react';\nimport { showDialog, Dialog, Toolbar, ToolbarButtonComponent, UseSignal, addToolbarButtonClass, ReactWidget, ToolbarButton, sessionContextDialogs } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { addIcon, copyIcon, cutIcon, fastForwardIcon, HTMLSelect, pasteIcon, runIcon, saveIcon } from '@jupyterlab/ui-components';\nimport { NotebookActions } from './actions';\n/**\n * The class name added to toolbar cell type dropdown wrapper.\n */\nconst TOOLBAR_CELLTYPE_CLASS = 'jp-Notebook-toolbarCellType';\n/**\n * The class name added to toolbar cell type dropdown.\n */\nconst TOOLBAR_CELLTYPE_DROPDOWN_CLASS = 'jp-Notebook-toolbarCellTypeDropdown';\n/**\n * A namespace for the default toolbar items.\n */\nexport var ToolbarItems;\n(function (ToolbarItems) {\n    /**\n     * Create save button toolbar item.\n     */\n    function createSaveButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        function onClick() {\n            if (panel.context.model.readOnly) {\n                return showDialog({\n                    title: trans.__('Cannot Save'),\n                    body: trans.__('Document is read-only'),\n                    buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n                });\n            }\n            void panel.context.save().then(() => {\n                if (!panel.isDisposed) {\n                    return panel.context.createCheckpoint();\n                }\n            });\n        }\n        return addToolbarButtonClass(ReactWidget.create(React.createElement(UseSignal, { signal: panel.context.fileChanged }, () => (React.createElement(ToolbarButtonComponent, { icon: saveIcon, onClick: onClick, tooltip: trans.__('Save the notebook contents and create checkpoint'), enabled: !!(panel &&\n                panel.context &&\n                panel.context.contentsModel &&\n                panel.context.contentsModel.writable) })))));\n    }\n    ToolbarItems.createSaveButton = createSaveButton;\n    /**\n     * Create an insert toolbar item.\n     */\n    function createInsertButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: addIcon,\n            onClick: () => {\n                NotebookActions.insertBelow(panel.content);\n            },\n            tooltip: trans.__('Insert a cell below')\n        });\n    }\n    ToolbarItems.createInsertButton = createInsertButton;\n    /**\n     * Create a cut toolbar item.\n     */\n    function createCutButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: cutIcon,\n            onClick: () => {\n                NotebookActions.cut(panel.content);\n            },\n            tooltip: trans.__('Cut the selected cells')\n        });\n    }\n    ToolbarItems.createCutButton = createCutButton;\n    /**\n     * Create a copy toolbar item.\n     */\n    function createCopyButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: copyIcon,\n            onClick: () => {\n                NotebookActions.copy(panel.content);\n            },\n            tooltip: trans.__('Copy the selected cells')\n        });\n    }\n    ToolbarItems.createCopyButton = createCopyButton;\n    /**\n     * Create a paste toolbar item.\n     */\n    function createPasteButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: pasteIcon,\n            onClick: () => {\n                NotebookActions.paste(panel.content);\n            },\n            tooltip: trans.__('Paste cells from the clipboard')\n        });\n    }\n    ToolbarItems.createPasteButton = createPasteButton;\n    /**\n     * Create a run toolbar item.\n     */\n    function createRunButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: runIcon,\n            onClick: () => {\n                void NotebookActions.runAndAdvance(panel.content, panel.sessionContext);\n            },\n            tooltip: trans.__('Run the selected cells and advance')\n        });\n    }\n    ToolbarItems.createRunButton = createRunButton;\n    /**\n     * Create a restart run all toolbar item\n     */\n    function createRestartRunAllButton(panel, dialogs, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: fastForwardIcon,\n            onClick: () => {\n                void (dialogs !== null && dialogs !== void 0 ? dialogs : sessionContextDialogs)\n                    .restart(panel.sessionContext, translator)\n                    .then(restarted => {\n                    if (restarted) {\n                        void NotebookActions.runAll(panel.content, panel.sessionContext);\n                    }\n                    return restarted;\n                });\n            },\n            tooltip: trans.__('Restart the kernel, then re-run the whole notebook')\n        });\n    }\n    ToolbarItems.createRestartRunAllButton = createRestartRunAllButton;\n    /**\n     * Create a cell type switcher item.\n     *\n     * #### Notes\n     * It will display the type of the current active cell.\n     * If more than one cell is selected but are of different types,\n     * it will display `'-'`.\n     * When the user changes the cell type, it will change the\n     * cell types of the selected cells.\n     * It can handle a change to the context.\n     */\n    function createCellTypeItem(panel, translator) {\n        return new CellTypeSwitcher(panel.content, translator);\n    }\n    ToolbarItems.createCellTypeItem = createCellTypeItem;\n    /**\n     * Get the default toolbar items for panel\n     */\n    function getDefaultItems(panel, sessionDialogs, translator) {\n        return [\n            { name: 'save', widget: createSaveButton(panel, translator) },\n            { name: 'insert', widget: createInsertButton(panel, translator) },\n            { name: 'cut', widget: createCutButton(panel, translator) },\n            { name: 'copy', widget: createCopyButton(panel, translator) },\n            { name: 'paste', widget: createPasteButton(panel, translator) },\n            { name: 'run', widget: createRunButton(panel, translator) },\n            {\n                name: 'interrupt',\n                widget: Toolbar.createInterruptButton(panel.sessionContext, translator)\n            },\n            {\n                name: 'restart',\n                widget: Toolbar.createRestartButton(panel.sessionContext, sessionDialogs, translator)\n            },\n            {\n                name: 'restart-and-run',\n                widget: createRestartRunAllButton(panel, sessionDialogs, translator)\n            },\n            { name: 'cellType', widget: createCellTypeItem(panel, translator) },\n            { name: 'spacer', widget: Toolbar.createSpacerItem() },\n            {\n                name: 'kernelName',\n                widget: Toolbar.createKernelNameItem(panel.sessionContext, sessionDialogs, translator)\n            },\n            {\n                name: 'kernelStatus',\n                widget: Toolbar.createKernelStatusItem(panel.sessionContext, translator)\n            }\n        ];\n    }\n    ToolbarItems.getDefaultItems = getDefaultItems;\n})(ToolbarItems || (ToolbarItems = {}));\n/**\n * A toolbar widget that switches cell types.\n */\nexport class CellTypeSwitcher extends ReactWidget {\n    /**\n     * Construct a new cell type switcher.\n     */\n    constructor(widget, translator) {\n        super();\n        /**\n         * Handle `change` events for the HTMLSelect component.\n         */\n        this.handleChange = (event) => {\n            if (event.target.value !== '-') {\n                NotebookActions.changeCellType(this._notebook, event.target.value);\n                this._notebook.activate();\n            }\n        };\n        /**\n         * Handle `keydown` events for the HTMLSelect component.\n         */\n        this.handleKeyDown = (event) => {\n            if (event.keyCode === 13) {\n                this._notebook.activate();\n            }\n        };\n        this._trans = (translator || nullTranslator).load('jupyterlab');\n        this.addClass(TOOLBAR_CELLTYPE_CLASS);\n        this._notebook = widget;\n        if (widget.model) {\n            this.update();\n        }\n        widget.activeCellChanged.connect(this.update, this);\n        // Follow a change in the selection.\n        widget.selectionChanged.connect(this.update, this);\n    }\n    render() {\n        let value = '-';\n        if (this._notebook.activeCell) {\n            value = this._notebook.activeCell.model.type;\n        }\n        for (const widget of this._notebook.widgets) {\n            if (this._notebook.isSelectedOrActive(widget)) {\n                if (widget.model.type !== value) {\n                    value = '-';\n                    break;\n                }\n            }\n        }\n        return (React.createElement(HTMLSelect, { className: TOOLBAR_CELLTYPE_DROPDOWN_CLASS, onChange: this.handleChange, onKeyDown: this.handleKeyDown, value: value, \"aria-label\": this._trans.__('Cell type') },\n            React.createElement(\"option\", { value: \"-\" }, \"-\"),\n            React.createElement(\"option\", { value: \"code\" }, this._trans.__('Code')),\n            React.createElement(\"option\", { value: \"markdown\" }, this._trans.__('Markdown')),\n            React.createElement(\"option\", { value: \"raw\" }, this._trans.__('Raw'))));\n    }\n}\n//# sourceMappingURL=default-toolbar.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ArrayExt, each, toArray, ArrayIterator } from '@lumino/algorithm';\nimport { Signal } from '@lumino/signaling';\nimport { ObservableMap } from '@jupyterlab/observables';\n/**\n * A cell list object that supports undo/redo.\n */\nexport class CellList {\n    /**\n     * Construct the cell list.\n     */\n    constructor(modelDB, factory) {\n        this._isDisposed = false;\n        this._changed = new Signal(this);\n        this._factory = factory;\n        this._cellOrder = modelDB.createList('cellOrder');\n        this._cellMap = new ObservableMap();\n        this._cellOrder.changed.connect(this._onOrderChanged, this);\n    }\n    /**\n     * A signal emitted when the cell list has changed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Test whether the cell list has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Test whether the list is empty.\n     *\n     * @returns `true` if the cell list is empty, `false` otherwise.\n     *\n     * #### Notes\n     * This is a read-only property.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    get isEmpty() {\n        return this._cellOrder.length === 0;\n    }\n    /**\n     * Get the length of the cell list.\n     *\n     * @return The number of cells in the cell list.\n     *\n     * #### Notes\n     * This is a read-only property.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    get length() {\n        return this._cellOrder.length;\n    }\n    /**\n     * Create an iterator over the cells in the cell list.\n     *\n     * @returns A new iterator starting at the front of the cell list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     */\n    iter() {\n        const arr = [];\n        for (const id of toArray(this._cellOrder)) {\n            arr.push(this._cellMap.get(id));\n        }\n        return new ArrayIterator(arr);\n    }\n    /**\n     * Dispose of the resources held by the cell list.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n        // Clean up the cell map and cell order objects.\n        for (const cell of this._cellMap.values()) {\n            cell.dispose();\n        }\n        this._cellMap.dispose();\n        this._cellOrder.dispose();\n    }\n    /**\n     * Get the cell at the specified index.\n     *\n     * @param index - The positive integer index of interest.\n     *\n     * @returns The cell at the specified index.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral or out of range.\n     */\n    get(index) {\n        return this._cellMap.get(this._cellOrder.get(index));\n    }\n    /**\n     * Set the cell at the specified index.\n     *\n     * @param index - The positive integer index of interest.\n     *\n     * @param cell - The cell to set at the specified index.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral or out of range.\n     *\n     * #### Notes\n     * This should be considered to transfer ownership of the\n     * cell to the `CellList`. As such, `cell.dispose()` should\n     * not be called by other actors.\n     */\n    set(index, cell) {\n        // Set the internal data structures.\n        this._cellMap.set(cell.id, cell);\n        this._cellOrder.set(index, cell.id);\n    }\n    /**\n     * Add a cell to the back of the cell list.\n     *\n     * @param cell - The cell to add to the back of the cell list.\n     *\n     * @returns The new length of the cell list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * This should be considered to transfer ownership of the\n     * cell to the `CellList`. As such, `cell.dispose()` should\n     * not be called by other actors.\n     */\n    push(cell) {\n        // Set the internal data structures.\n        this._cellMap.set(cell.id, cell);\n        const num = this._cellOrder.push(cell.id);\n        return num;\n    }\n    /**\n     * Insert a cell into the cell list at a specific index.\n     *\n     * @param index - The index at which to insert the cell.\n     *\n     * @param cell - The cell to set at the specified index.\n     *\n     * @returns The new length of the cell list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * The `index` will be clamped to the bounds of the cell list.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Notes\n     * This should be considered to transfer ownership of the\n     * cell to the `CellList`. As such, `cell.dispose()` should\n     * not be called by other actors.\n     */\n    insert(index, cell) {\n        // Set the internal data structures.\n        this._cellMap.set(cell.id, cell);\n        this._cellOrder.insert(index, cell.id);\n    }\n    /**\n     * Remove the first occurrence of a cell from the cell list.\n     *\n     * @param cell - The cell of interest.\n     *\n     * @returns The index of the removed cell, or `-1` if the cell\n     *   is not contained in the cell list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the removed cell and beyond are invalidated.\n     */\n    removeValue(cell) {\n        const index = ArrayExt.findFirstIndex(toArray(this._cellOrder), id => this._cellMap.get(id) === cell);\n        this.remove(index);\n        return index;\n    }\n    /**\n     * Remove and return the cell at a specific index.\n     *\n     * @param index - The index of the cell of interest.\n     *\n     * @returns The cell at the specified index, or `undefined` if the\n     *   index is out of range.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the removed cell and beyond are invalidated.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     */\n    remove(index) {\n        const id = this._cellOrder.get(index);\n        this._cellOrder.remove(index);\n        const cell = this._cellMap.get(id);\n        return cell;\n    }\n    /**\n     * Remove all cells from the cell list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * All current iterators are invalidated.\n     */\n    clear() {\n        this._cellOrder.clear();\n    }\n    /**\n     * Move a cell from one index to another.\n     *\n     * @parm fromIndex - The index of the element to move.\n     *\n     * @param toIndex - The index to move the element to.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Iterator Validity\n     * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`\n     * and beyond are invalidated.\n     *\n     * #### Undefined Behavior\n     * A `fromIndex` or a `toIndex` which is non-integral.\n     */\n    move(fromIndex, toIndex) {\n        this._cellOrder.move(fromIndex, toIndex);\n    }\n    /**\n     * Push a set of cells to the back of the cell list.\n     *\n     * @param cells - An iterable or array-like set of cells to add.\n     *\n     * @returns The new length of the cell list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * This should be considered to transfer ownership of the\n     * cells to the `CellList`. As such, `cell.dispose()` should\n     * not be called by other actors.\n     */\n    pushAll(cells) {\n        const newValues = toArray(cells);\n        each(newValues, cell => {\n            // Set the internal data structures.\n            this._cellMap.set(cell.id, cell);\n            this._cellOrder.push(cell.id);\n        });\n        return this.length;\n    }\n    /**\n     * Insert a set of items into the cell list at the specified index.\n     *\n     * @param index - The index at which to insert the cells.\n     *\n     * @param cells - The cells to insert at the specified index.\n     *\n     * @returns The new length of the cell list.\n     *\n     * #### Complexity.\n     * Linear.\n     *\n     * #### Iterator Validity\n     * No changes.\n     *\n     * #### Notes\n     * The `index` will be clamped to the bounds of the cell list.\n     *\n     * #### Undefined Behavior.\n     * An `index` which is non-integral.\n     *\n     * #### Notes\n     * This should be considered to transfer ownership of the\n     * cells to the `CellList`. As such, `cell.dispose()` should\n     * not be called by other actors.\n     */\n    insertAll(index, cells) {\n        const newValues = toArray(cells);\n        each(newValues, cell => {\n            this._cellMap.set(cell.id, cell);\n            this._cellOrder.beginCompoundOperation();\n            this._cellOrder.insert(index++, cell.id);\n            this._cellOrder.endCompoundOperation();\n        });\n        return this.length;\n    }\n    /**\n     * Remove a range of items from the cell list.\n     *\n     * @param startIndex - The start index of the range to remove (inclusive).\n     *\n     * @param endIndex - The end index of the range to remove (exclusive).\n     *\n     * @returns The new length of the cell list.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Iterator Validity\n     * Iterators pointing to the first removed cell and beyond are invalid.\n     *\n     * #### Undefined Behavior\n     * A `startIndex` or `endIndex` which is non-integral.\n     */\n    removeRange(startIndex, endIndex) {\n        this._cellOrder.removeRange(startIndex, endIndex);\n        return this.length;\n    }\n    /**\n     * Whether the object can redo changes.\n     */\n    get canRedo() {\n        return this._cellOrder.canRedo;\n    }\n    /**\n     * Whether the object can undo changes.\n     */\n    get canUndo() {\n        return this._cellOrder.canUndo;\n    }\n    /**\n     * Begin a compound operation.\n     *\n     * @param isUndoAble - Whether the operation is undoable.\n     *   The default is `true`.\n     */\n    beginCompoundOperation(isUndoAble) {\n        this._cellOrder.beginCompoundOperation(isUndoAble);\n    }\n    /**\n     * End a compound operation.\n     */\n    endCompoundOperation() {\n        this._cellOrder.endCompoundOperation();\n    }\n    /**\n     * Undo an operation.\n     */\n    undo() {\n        this._cellOrder.undo();\n    }\n    /**\n     * Redo an operation.\n     */\n    redo() {\n        this._cellOrder.redo();\n    }\n    /**\n     * Clear the change stack.\n     */\n    clearUndo() {\n        // Dispose of cells not in the current\n        // cell order.\n        for (const key of this._cellMap.keys()) {\n            if (ArrayExt.findFirstIndex(toArray(this._cellOrder), id => id === key) ===\n                -1) {\n                const cell = this._cellMap.get(key);\n                cell.dispose();\n                this._cellMap.delete(key);\n            }\n        }\n        this._cellOrder.clearUndo();\n    }\n    _onOrderChanged(order, change) {\n        if (change.type === 'add' || change.type === 'set') {\n            each(change.newValues, id => {\n                if (!this._cellMap.has(id)) {\n                    const cellDB = this._factory.modelDB;\n                    const cellType = cellDB.createValue(id + '.type');\n                    let cell;\n                    switch (cellType.get()) {\n                        case 'code':\n                            cell = this._factory.createCodeCell({ id: id });\n                            break;\n                        case 'markdown':\n                            cell = this._factory.createMarkdownCell({ id: id });\n                            break;\n                        default:\n                            cell = this._factory.createRawCell({ id: id });\n                            break;\n                    }\n                    this._cellMap.set(id, cell);\n                }\n            });\n        }\n        const newValues = [];\n        const oldValues = [];\n        each(change.newValues, id => {\n            newValues.push(this._cellMap.get(id));\n        });\n        each(change.oldValues, id => {\n            oldValues.push(this._cellMap.get(id));\n        });\n        this._changed.emit({\n            type: change.type,\n            oldIndex: change.oldIndex,\n            newIndex: change.newIndex,\n            oldValues,\n            newValues\n        });\n    }\n}\n//# sourceMappingURL=celllist.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DocumentModel } from '@jupyterlab/docregistry';\nimport { CodeCellModel, RawCellModel, MarkdownCellModel } from '@jupyterlab/cells';\nimport * as nbformat from '@jupyterlab/nbformat';\nimport { UUID } from '@lumino/coreutils';\nimport { CellList } from './celllist';\nimport { showDialog, Dialog } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\n/**\n * An implementation of a notebook Model.\n */\nexport class NotebookModel extends DocumentModel {\n    /**\n     * Construct a new notebook model.\n     */\n    constructor(options = {}) {\n        super(options.languagePreference, options.modelDB);\n        this._nbformat = nbformat.MAJOR_VERSION;\n        this._nbformatMinor = nbformat.MINOR_VERSION;\n        const factory = options.contentFactory || NotebookModel.defaultContentFactory;\n        this.contentFactory = factory.clone(this.modelDB.view('cells'));\n        this._cells = new CellList(this.modelDB, this.contentFactory);\n        this._trans = (options.translator || nullTranslator).load('jupyterlab');\n        this._cells.changed.connect(this._onCellsChanged, this);\n        // Handle initial metadata.\n        const metadata = this.modelDB.createMap('metadata');\n        if (!metadata.has('language_info')) {\n            const name = options.languagePreference || '';\n            metadata.set('language_info', { name });\n        }\n        this._ensureMetadata();\n        metadata.changed.connect(this.triggerContentChange, this);\n        this._deletedCells = [];\n    }\n    /**\n     * The metadata associated with the notebook.\n     */\n    get metadata() {\n        return this.modelDB.get('metadata');\n    }\n    /**\n     * Get the observable list of notebook cells.\n     */\n    get cells() {\n        return this._cells;\n    }\n    /**\n     * The major version number of the nbformat.\n     */\n    get nbformat() {\n        return this._nbformat;\n    }\n    /**\n     * The minor version number of the nbformat.\n     */\n    get nbformatMinor() {\n        return this._nbformatMinor;\n    }\n    /**\n     * The default kernel name of the document.\n     */\n    get defaultKernelName() {\n        const spec = this.metadata.get('kernelspec');\n        return spec ? spec.name : '';\n    }\n    /**\n     * A list of deleted cells for the notebook..\n     */\n    get deletedCells() {\n        return this._deletedCells;\n    }\n    /**\n     * The default kernel language of the document.\n     */\n    get defaultKernelLanguage() {\n        const info = this.metadata.get('language_info');\n        return info ? info.name : '';\n    }\n    /**\n     * Dispose of the resources held by the model.\n     */\n    dispose() {\n        // Do nothing if already disposed.\n        if (this.isDisposed) {\n            return;\n        }\n        const cells = this.cells;\n        this._cells = null;\n        cells.dispose();\n        super.dispose();\n    }\n    /**\n     * Serialize the model to a string.\n     */\n    toString() {\n        return JSON.stringify(this.toJSON());\n    }\n    /**\n     * Deserialize the model from a string.\n     *\n     * #### Notes\n     * Should emit a [contentChanged] signal.\n     */\n    fromString(value) {\n        this.fromJSON(JSON.parse(value));\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        var _a, _b;\n        const cells = [];\n        for (let i = 0; i < ((_b = (_a = this.cells) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0); i++) {\n            const cell = this.cells.get(i).toJSON();\n            if (this._nbformat === 4 && this._nbformatMinor <= 4) {\n                // strip cell ids if we have notebook format 4.0-4.4\n                delete cell.id;\n            }\n            cells.push(cell);\n        }\n        this._ensureMetadata();\n        const metadata = Object.create(null);\n        for (const key of this.metadata.keys()) {\n            metadata[key] = JSON.parse(JSON.stringify(this.metadata.get(key)));\n        }\n        return {\n            metadata,\n            nbformat_minor: this._nbformatMinor,\n            nbformat: this._nbformat,\n            cells\n        };\n    }\n    /**\n     * Deserialize the model from JSON.\n     *\n     * #### Notes\n     * Should emit a [contentChanged] signal.\n     */\n    fromJSON(value) {\n        const cells = [];\n        const factory = this.contentFactory;\n        const useId = value.nbformat === 4 && value.nbformat_minor >= 5;\n        for (const cell of value.cells) {\n            const options = { cell };\n            if (useId) {\n                options.id = cell.id;\n            }\n            switch (cell.cell_type) {\n                case 'code':\n                    cells.push(factory.createCodeCell(options));\n                    break;\n                case 'markdown':\n                    cells.push(factory.createMarkdownCell(options));\n                    break;\n                case 'raw':\n                    cells.push(factory.createRawCell(options));\n                    break;\n                default:\n                    continue;\n            }\n        }\n        this.cells.beginCompoundOperation();\n        this.cells.clear();\n        this.cells.pushAll(cells);\n        this.cells.endCompoundOperation();\n        let oldValue = 0;\n        let newValue = 0;\n        this._nbformatMinor = nbformat.MINOR_VERSION;\n        this._nbformat = nbformat.MAJOR_VERSION;\n        const origNbformat = value.metadata.orig_nbformat;\n        if (value.nbformat !== this._nbformat) {\n            oldValue = this._nbformat;\n            this._nbformat = newValue = value.nbformat;\n            this.triggerStateChange({ name: 'nbformat', oldValue, newValue });\n        }\n        if (value.nbformat_minor > this._nbformatMinor) {\n            oldValue = this._nbformatMinor;\n            this._nbformatMinor = newValue = value.nbformat_minor;\n            this.triggerStateChange({ name: 'nbformatMinor', oldValue, newValue });\n        }\n        // Alert the user if the format changes.\n        if (origNbformat !== undefined && this._nbformat !== origNbformat) {\n            const newer = this._nbformat > origNbformat;\n            let msg;\n            if (newer) {\n                msg = this._trans.__(`This notebook has been converted from an older notebook format (v%1)\nto the current notebook format (v%2).\nThe next time you save this notebook, the current notebook format (vthis._nbformat) will be used.\n'Older versions of Jupyter may not be able to read the new format.' To preserve the original format version,\nclose the notebook without saving it.`, origNbformat, this._nbformat);\n            }\n            else {\n                msg = this._trans.__(`This notebook has been converted from an newer notebook format (v%1)\nto the current notebook format (v%2).\nThe next time you save this notebook, the current notebook format (v%2) will be used.\nSome features of the original notebook may not be available.' To preserve the original format version,\nclose the notebook without saving it.`, origNbformat, this._nbformat);\n            }\n            void showDialog({\n                title: this._trans.__('Notebook converted'),\n                body: msg,\n                buttons: [Dialog.okButton({ label: this._trans.__('Ok') })]\n            });\n        }\n        // Update the metadata.\n        this.metadata.clear();\n        const metadata = value.metadata;\n        for (const key in metadata) {\n            // orig_nbformat is not intended to be stored per spec.\n            if (key === 'orig_nbformat') {\n                continue;\n            }\n            this.metadata.set(key, metadata[key]);\n        }\n        this._ensureMetadata();\n        this.dirty = true;\n    }\n    /**\n     * Initialize the model with its current state.\n     *\n     * # Notes\n     * Adds an empty code cell if the model is empty\n     * and clears undo state.\n     */\n    initialize() {\n        super.initialize();\n        if (!this.cells.length) {\n            const factory = this.contentFactory;\n            this.cells.push(factory.createCodeCell({}));\n        }\n        this.cells.clearUndo();\n    }\n    /**\n     * Handle a change in the cells list.\n     */\n    _onCellsChanged(list, change) {\n        switch (change.type) {\n            case 'add':\n                change.newValues.forEach(cell => {\n                    cell.contentChanged.connect(this.triggerContentChange, this);\n                });\n                break;\n            case 'remove':\n                break;\n            case 'set':\n                change.newValues.forEach(cell => {\n                    cell.contentChanged.connect(this.triggerContentChange, this);\n                });\n                break;\n            default:\n                break;\n        }\n        this.triggerContentChange();\n    }\n    /**\n     * Make sure we have the required metadata fields.\n     */\n    _ensureMetadata() {\n        const metadata = this.metadata;\n        if (!metadata.has('language_info')) {\n            metadata.set('language_info', { name: '' });\n        }\n        if (!metadata.has('kernelspec')) {\n            metadata.set('kernelspec', { name: '', display_name: '' });\n        }\n    }\n}\n/**\n * The namespace for the `NotebookModel` class statics.\n */\n(function (NotebookModel) {\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory {\n        /**\n         * Create a new cell model factory.\n         */\n        constructor(options) {\n            this.codeCellContentFactory =\n                options.codeCellContentFactory || CodeCellModel.defaultContentFactory;\n            this.modelDB = options.modelDB;\n        }\n        /**\n         * Create a new cell by cell type.\n         *\n         * @param type:  the type of the cell to create.\n         *\n         * @param options: the cell creation options.\n         *\n         * #### Notes\n         * This method is intended to be a convenience method to programmaticaly\n         * call the other cell creation methods in the factory.\n         */\n        createCell(type, opts) {\n            switch (type) {\n                case 'code':\n                    return this.createCodeCell(opts);\n                case 'markdown':\n                    return this.createMarkdownCell(opts);\n                case 'raw':\n                default:\n                    return this.createRawCell(opts);\n            }\n        }\n        /**\n         * Create a new code cell.\n         *\n         * @param source - The data to use for the original source data.\n         *\n         * @returns A new code cell. If a source cell is provided, the\n         *   new cell will be initialized with the data from the source.\n         *   If the contentFactory is not provided, the instance\n         *   `codeCellContentFactory` will be used.\n         */\n        createCodeCell(options) {\n            if (options.contentFactory) {\n                options.contentFactory = this.codeCellContentFactory;\n            }\n            if (this.modelDB) {\n                if (!options.id) {\n                    options.id = UUID.uuid4();\n                }\n                options.modelDB = this.modelDB.view(options.id);\n            }\n            return new CodeCellModel(options);\n        }\n        /**\n         * Create a new markdown cell.\n         *\n         * @param source - The data to use for the original source data.\n         *\n         * @returns A new markdown cell. If a source cell is provided, the\n         *   new cell will be initialized with the data from the source.\n         */\n        createMarkdownCell(options) {\n            if (this.modelDB) {\n                if (!options.id) {\n                    options.id = UUID.uuid4();\n                }\n                options.modelDB = this.modelDB.view(options.id);\n            }\n            return new MarkdownCellModel(options);\n        }\n        /**\n         * Create a new raw cell.\n         *\n         * @param source - The data to use for the original source data.\n         *\n         * @returns A new raw cell. If a source cell is provided, the\n         *   new cell will be initialized with the data from the source.\n         */\n        createRawCell(options) {\n            if (this.modelDB) {\n                if (!options.id) {\n                    options.id = UUID.uuid4();\n                }\n                options.modelDB = this.modelDB.view(options.id);\n            }\n            return new RawCellModel(options);\n        }\n        /**\n         * Clone the content factory with a new IModelDB.\n         */\n        clone(modelDB) {\n            return new ContentFactory({\n                modelDB: modelDB,\n                codeCellContentFactory: this.codeCellContentFactory\n            });\n        }\n    }\n    NotebookModel.ContentFactory = ContentFactory;\n    /**\n     * The default `ContentFactory` instance.\n     */\n    NotebookModel.defaultContentFactory = new ContentFactory({});\n})(NotebookModel || (NotebookModel = {}));\n//# sourceMappingURL=model.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { NotebookModel } from './model';\n/**\n * A model factory for notebooks.\n */\nexport class NotebookModelFactory {\n    /**\n     * Construct a new notebook model factory.\n     */\n    constructor(options) {\n        this._disposed = false;\n        const codeCellContentFactory = options.codeCellContentFactory;\n        this.contentFactory =\n            options.contentFactory ||\n                new NotebookModel.ContentFactory({ codeCellContentFactory });\n    }\n    /**\n     * The name of the model.\n     */\n    get name() {\n        return 'notebook';\n    }\n    /**\n     * The content type of the file.\n     */\n    get contentType() {\n        return 'notebook';\n    }\n    /**\n     * The format of the file.\n     */\n    get fileFormat() {\n        return 'json';\n    }\n    /**\n     * Get whether the model factory has been disposed.\n     */\n    get isDisposed() {\n        return this._disposed;\n    }\n    /**\n     * Dispose of the model factory.\n     */\n    dispose() {\n        this._disposed = true;\n    }\n    /**\n     * Create a new model for a given path.\n     *\n     * @param languagePreference - An optional kernel language preference.\n     *\n     * @returns A new document model.\n     */\n    createNew(languagePreference, modelDB) {\n        const contentFactory = this.contentFactory;\n        return new NotebookModel({ languagePreference, contentFactory, modelDB });\n    }\n    /**\n     * Get the preferred kernel language given a path.\n     */\n    preferredLanguage(path) {\n        return '';\n    }\n}\n//# sourceMappingURL=modelfactory.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ArrayExt, each, chain } from '@lumino/algorithm';\nimport { ConflatableMessage, MessageLoop } from '@lumino/messaging';\nimport { h, VirtualDOM } from '@lumino/virtualdom';\nimport { PanelLayout, Widget } from '@lumino/widgets';\nimport { Collapse, Styling } from '@jupyterlab/apputils';\nimport { CodeEditor, CodeEditorWrapper, JSONEditor } from '@jupyterlab/codeeditor';\nimport { ObservableJSON } from '@jupyterlab/observables';\nimport { nullTranslator } from '@jupyterlab/translation';\nclass RankedPanel extends Widget {\n    constructor() {\n        super();\n        this._items = [];\n        this.layout = new PanelLayout();\n        this.addClass('jp-RankedPanel');\n    }\n    addWidget(widget, rank) {\n        const rankItem = { widget, rank };\n        const index = ArrayExt.upperBound(this._items, rankItem, Private.itemCmp);\n        ArrayExt.insert(this._items, index, rankItem);\n        const layout = this.layout;\n        layout.insertWidget(index, widget);\n    }\n    /**\n     * Handle the removal of a child\n     *\n     */\n    onChildRemoved(msg) {\n        const index = ArrayExt.findFirstIndex(this._items, item => item.widget === msg.child);\n        if (index !== -1) {\n            ArrayExt.removeAt(this._items, index);\n        }\n    }\n}\n/**\n * A widget that provides metadata tools.\n */\nexport class NotebookTools extends Widget {\n    /**\n     * Construct a new NotebookTools object.\n     */\n    constructor(options) {\n        super();\n        this.addClass('jp-NotebookTools');\n        this.translator = options.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        this._commonTools = new RankedPanel();\n        this._advancedTools = new RankedPanel();\n        this._advancedTools.title.label = this._trans.__('Advanced Tools');\n        const layout = (this.layout = new PanelLayout());\n        layout.addWidget(this._commonTools);\n        layout.addWidget(new Collapse({ widget: this._advancedTools }));\n        this._tracker = options.tracker;\n        this._tracker.currentChanged.connect(this._onActiveNotebookPanelChanged, this);\n        this._tracker.activeCellChanged.connect(this._onActiveCellChanged, this);\n        this._tracker.selectionChanged.connect(this._onSelectionChanged, this);\n        this._onActiveNotebookPanelChanged();\n        this._onActiveCellChanged();\n        this._onSelectionChanged();\n    }\n    /**\n     * The active cell widget.\n     */\n    get activeCell() {\n        return this._tracker.activeCell;\n    }\n    /**\n     * The currently selected cells.\n     */\n    get selectedCells() {\n        const panel = this._tracker.currentWidget;\n        if (!panel) {\n            return [];\n        }\n        const notebook = panel.content;\n        return notebook.widgets.filter(cell => notebook.isSelectedOrActive(cell));\n    }\n    /**\n     * The current notebook.\n     */\n    get activeNotebookPanel() {\n        return this._tracker.currentWidget;\n    }\n    /**\n     * Add a cell tool item.\n     */\n    addItem(options) {\n        var _a;\n        const tool = options.tool;\n        const rank = (_a = options.rank) !== null && _a !== void 0 ? _a : 100;\n        let section;\n        if (options.section === 'advanced') {\n            section = this._advancedTools;\n        }\n        else {\n            section = this._commonTools;\n        }\n        tool.addClass('jp-NotebookTools-tool');\n        section.addWidget(tool, rank);\n        // TODO: perhaps the necessary notebookTools functionality should be\n        // consolidated into a single object, rather than a broad reference to this.\n        tool.notebookTools = this;\n        // Trigger the tool to update its active notebook and cell.\n        MessageLoop.sendMessage(tool, NotebookTools.ActiveNotebookPanelMessage);\n        MessageLoop.sendMessage(tool, NotebookTools.ActiveCellMessage);\n    }\n    /**\n     * Handle a change to the notebook panel.\n     */\n    _onActiveNotebookPanelChanged() {\n        if (this._prevActiveNotebookModel &&\n            !this._prevActiveNotebookModel.isDisposed) {\n            this._prevActiveNotebookModel.metadata.changed.disconnect(this._onActiveNotebookPanelMetadataChanged, this);\n        }\n        const activeNBModel = this.activeNotebookPanel && this.activeNotebookPanel.content\n            ? this.activeNotebookPanel.content.model\n            : null;\n        this._prevActiveNotebookModel = activeNBModel;\n        if (activeNBModel) {\n            activeNBModel.metadata.changed.connect(this._onActiveNotebookPanelMetadataChanged, this);\n        }\n        each(this._toolChildren(), widget => {\n            MessageLoop.sendMessage(widget, NotebookTools.ActiveNotebookPanelMessage);\n        });\n    }\n    /**\n     * Handle a change to the active cell.\n     */\n    _onActiveCellChanged() {\n        if (this._prevActiveCell && !this._prevActiveCell.isDisposed) {\n            this._prevActiveCell.metadata.changed.disconnect(this._onActiveCellMetadataChanged, this);\n        }\n        const activeCell = this.activeCell ? this.activeCell.model : null;\n        this._prevActiveCell = activeCell;\n        if (activeCell) {\n            activeCell.metadata.changed.connect(this._onActiveCellMetadataChanged, this);\n        }\n        each(this._toolChildren(), widget => {\n            MessageLoop.sendMessage(widget, NotebookTools.ActiveCellMessage);\n        });\n    }\n    /**\n     * Handle a change in the selection.\n     */\n    _onSelectionChanged() {\n        each(this._toolChildren(), widget => {\n            MessageLoop.sendMessage(widget, NotebookTools.SelectionMessage);\n        });\n    }\n    /**\n     * Handle a change in the active cell metadata.\n     */\n    _onActiveNotebookPanelMetadataChanged(sender, args) {\n        const message = new ObservableJSON.ChangeMessage('activenotebookpanel-metadata-changed', args);\n        each(this._toolChildren(), widget => {\n            MessageLoop.sendMessage(widget, message);\n        });\n    }\n    /**\n     * Handle a change in the notebook model metadata.\n     */\n    _onActiveCellMetadataChanged(sender, args) {\n        const message = new ObservableJSON.ChangeMessage('activecell-metadata-changed', args);\n        each(this._toolChildren(), widget => {\n            MessageLoop.sendMessage(widget, message);\n        });\n    }\n    _toolChildren() {\n        return chain(this._commonTools.children(), this._advancedTools.children());\n    }\n}\n/**\n * The namespace for NotebookTools class statics.\n */\n(function (NotebookTools) {\n    /**\n     * A singleton conflatable `'activenotebookpanel-changed'` message.\n     */\n    NotebookTools.ActiveNotebookPanelMessage = new ConflatableMessage('activenotebookpanel-changed');\n    /**\n     * A singleton conflatable `'activecell-changed'` message.\n     */\n    NotebookTools.ActiveCellMessage = new ConflatableMessage('activecell-changed');\n    /**\n     * A singleton conflatable `'selection-changed'` message.\n     */\n    NotebookTools.SelectionMessage = new ConflatableMessage('selection-changed');\n    /**\n     * The base notebook tool, meant to be subclassed.\n     */\n    class Tool extends Widget {\n        dispose() {\n            super.dispose();\n            if (this.notebookTools) {\n                this.notebookTools = null;\n            }\n        }\n        /**\n         * Process a message sent to the widget.\n         *\n         * @param msg - The message sent to the widget.\n         */\n        processMessage(msg) {\n            super.processMessage(msg);\n            switch (msg.type) {\n                case 'activenotebookpanel-changed':\n                    this.onActiveNotebookPanelChanged(msg);\n                    break;\n                case 'activecell-changed':\n                    this.onActiveCellChanged(msg);\n                    break;\n                case 'selection-changed':\n                    this.onSelectionChanged(msg);\n                    break;\n                case 'activecell-metadata-changed':\n                    this.onActiveCellMetadataChanged(msg);\n                    break;\n                case 'activenotebookpanel-metadata-changed':\n                    this.onActiveNotebookPanelMetadataChanged(msg);\n                    break;\n                default:\n                    break;\n            }\n        }\n        /**\n         * Handle a change to the notebook panel.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveNotebookPanelChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the active cell.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveCellChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the selection.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onSelectionChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the metadata of the active cell.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveCellMetadataChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the metadata of the active cell.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveNotebookPanelMetadataChanged(msg) {\n            /* no-op */\n        }\n    }\n    NotebookTools.Tool = Tool;\n    /**\n     * A cell tool displaying the active cell contents.\n     */\n    class ActiveCellTool extends Tool {\n        /**\n         * Construct a new active cell tool.\n         */\n        constructor() {\n            super();\n            this._model = new CodeEditor.Model();\n            this.addClass('jp-ActiveCellTool');\n            this.addClass('jp-InputArea');\n            this.layout = new PanelLayout();\n        }\n        /**\n         * Dispose of the resources used by the tool.\n         */\n        dispose() {\n            if (this._model === null) {\n                return;\n            }\n            this._model.dispose();\n            this._model = null;\n            super.dispose();\n        }\n        /**\n         * Handle a change to the active cell.\n         */\n        onActiveCellChanged() {\n            const activeCell = this.notebookTools.activeCell;\n            const layout = this.layout;\n            const count = layout.widgets.length;\n            for (let i = 0; i < count; i++) {\n                layout.widgets[0].dispose();\n            }\n            if (this._cellModel && !this._cellModel.isDisposed) {\n                this._cellModel.value.changed.disconnect(this._onValueChanged, this);\n                this._cellModel.mimeTypeChanged.disconnect(this._onMimeTypeChanged, this);\n            }\n            if (!activeCell) {\n                const cell = new Widget();\n                cell.addClass('jp-InputArea-editor');\n                cell.addClass('jp-InputArea-editor');\n                layout.addWidget(cell);\n                this._cellModel = null;\n                return;\n            }\n            const promptNode = activeCell.promptNode\n                ? activeCell.promptNode.cloneNode(true)\n                : undefined;\n            const prompt = new Widget({ node: promptNode });\n            const factory = activeCell.contentFactory.editorFactory;\n            const cellModel = (this._cellModel = activeCell.model);\n            cellModel.value.changed.connect(this._onValueChanged, this);\n            cellModel.mimeTypeChanged.connect(this._onMimeTypeChanged, this);\n            this._model.value.text = cellModel.value.text.split('\\n')[0];\n            this._model.mimeType = cellModel.mimeType;\n            const model = this._model;\n            const editorWidget = new CodeEditorWrapper({ model, factory });\n            editorWidget.addClass('jp-InputArea-editor');\n            editorWidget.addClass('jp-InputArea-editor');\n            editorWidget.editor.setOption('readOnly', true);\n            layout.addWidget(prompt);\n            layout.addWidget(editorWidget);\n        }\n        /**\n         * Handle a change to the current editor value.\n         */\n        _onValueChanged() {\n            this._model.value.text = this._cellModel.value.text.split('\\n')[0];\n        }\n        /**\n         * Handle a change to the current editor mimetype.\n         */\n        _onMimeTypeChanged() {\n            this._model.mimeType = this._cellModel.mimeType;\n        }\n    }\n    NotebookTools.ActiveCellTool = ActiveCellTool;\n    /**\n     * A raw metadata editor.\n     */\n    class MetadataEditorTool extends Tool {\n        /**\n         * Construct a new raw metadata tool.\n         */\n        constructor(options) {\n            super();\n            const { editorFactory } = options;\n            this.addClass('jp-MetadataEditorTool');\n            const layout = (this.layout = new PanelLayout());\n            this.editor = new JSONEditor({\n                editorFactory\n            });\n            this.editor.title.label = options.label || 'Edit Metadata';\n            const titleNode = new Widget({ node: document.createElement('label') });\n            titleNode.node.textContent = options.label || 'Edit Metadata';\n            layout.addWidget(titleNode);\n            layout.addWidget(this.editor);\n        }\n    }\n    NotebookTools.MetadataEditorTool = MetadataEditorTool;\n    /**\n     * A notebook metadata editor\n     */\n    class NotebookMetadataEditorTool extends MetadataEditorTool {\n        constructor(options) {\n            const translator = options.translator || nullTranslator;\n            const trans = translator.load('jupyterlab');\n            options.label = options.label || trans.__('Notebook Metadata');\n            super(options);\n        }\n        /**\n         * Handle a change to the notebook.\n         */\n        onActiveNotebookPanelChanged(msg) {\n            this._update();\n        }\n        /**\n         * Handle a change to the notebook metadata.\n         */\n        onActiveNotebookPanelMetadataChanged(msg) {\n            this._update();\n        }\n        _update() {\n            var _a, _b;\n            const nb = this.notebookTools.activeNotebookPanel &&\n                this.notebookTools.activeNotebookPanel.content;\n            this.editor.source = (_b = (_a = nb === null || nb === void 0 ? void 0 : nb.model) === null || _a === void 0 ? void 0 : _a.metadata) !== null && _b !== void 0 ? _b : null;\n        }\n    }\n    NotebookTools.NotebookMetadataEditorTool = NotebookMetadataEditorTool;\n    /**\n     * A cell metadata editor\n     */\n    class CellMetadataEditorTool extends MetadataEditorTool {\n        constructor(options) {\n            const translator = options.translator || nullTranslator;\n            const trans = translator.load('jupyterlab');\n            options.label = options.label || trans.__('Cell Metadata');\n            super(options);\n        }\n        /**\n         * Handle a change to the active cell.\n         */\n        onActiveCellChanged(msg) {\n            this._update();\n        }\n        /**\n         * Handle a change to the active cell metadata.\n         */\n        onActiveCellMetadataChanged(msg) {\n            this._update();\n        }\n        _update() {\n            const cell = this.notebookTools.activeCell;\n            this.editor.source = cell ? cell.model.metadata : null;\n        }\n    }\n    NotebookTools.CellMetadataEditorTool = CellMetadataEditorTool;\n    /**\n     * A cell tool that provides a selection for a given metadata key.\n     */\n    class KeySelector extends Tool {\n        /**\n         * Construct a new KeySelector.\n         */\n        constructor(options) {\n            // TODO: use react\n            super({ node: Private.createSelectorNode(options) });\n            /**\n             * Get the value for the data.\n             */\n            this._getValue = (cell) => {\n                let value = cell.model.metadata.get(this.key);\n                if (value === undefined) {\n                    value = this._default;\n                }\n                return value;\n            };\n            /**\n             * Set the value for the data.\n             */\n            this._setValue = (cell, value) => {\n                if (value === this._default) {\n                    cell.model.metadata.delete(this.key);\n                }\n                else {\n                    cell.model.metadata.set(this.key, value);\n                }\n            };\n            this._changeGuard = false;\n            this.addClass('jp-KeySelector');\n            this.key = options.key;\n            this._default = options.default;\n            this._validCellTypes = options.validCellTypes || [];\n            this._getter = options.getter || this._getValue;\n            this._setter = options.setter || this._setValue;\n        }\n        /**\n         * The select node for the widget.\n         */\n        get selectNode() {\n            return this.node.getElementsByTagName('select')[0];\n        }\n        /**\n         * Handle the DOM events for the widget.\n         *\n         * @param event - The DOM event sent to the widget.\n         *\n         * #### Notes\n         * This method implements the DOM `EventListener` interface and is\n         * called in response to events on the notebook panel's node. It should\n         * not be called directly by user code.\n         */\n        handleEvent(event) {\n            switch (event.type) {\n                case 'change':\n                    this.onValueChanged();\n                    break;\n                default:\n                    break;\n            }\n        }\n        /**\n         * Handle `after-attach` messages for the widget.\n         */\n        onAfterAttach(msg) {\n            const node = this.selectNode;\n            node.addEventListener('change', this);\n        }\n        /**\n         * Handle `before-detach` messages for the widget.\n         */\n        onBeforeDetach(msg) {\n            const node = this.selectNode;\n            node.removeEventListener('change', this);\n        }\n        /**\n         * Handle a change to the active cell.\n         */\n        onActiveCellChanged(msg) {\n            const select = this.selectNode;\n            const activeCell = this.notebookTools.activeCell;\n            if (!activeCell) {\n                select.disabled = true;\n                select.value = '';\n                return;\n            }\n            const cellType = activeCell.model.type;\n            if (this._validCellTypes.length &&\n                this._validCellTypes.indexOf(cellType) === -1) {\n                select.value = '';\n                select.disabled = true;\n                return;\n            }\n            select.disabled = false;\n            this._changeGuard = true;\n            const getter = this._getter;\n            select.value = JSON.stringify(getter(activeCell));\n            this._changeGuard = false;\n        }\n        /**\n         * Handle a change to the metadata of the active cell.\n         */\n        onActiveCellMetadataChanged(msg) {\n            if (this._changeGuard) {\n                return;\n            }\n            const select = this.selectNode;\n            const cell = this.notebookTools.activeCell;\n            if (msg.args.key === this.key && cell) {\n                this._changeGuard = true;\n                const getter = this._getter;\n                select.value = JSON.stringify(getter(cell));\n                this._changeGuard = false;\n            }\n        }\n        /**\n         * Handle a change to the value.\n         */\n        onValueChanged() {\n            const activeCell = this.notebookTools.activeCell;\n            if (!activeCell || this._changeGuard) {\n                return;\n            }\n            this._changeGuard = true;\n            const select = this.selectNode;\n            const setter = this._setter;\n            setter(activeCell, JSON.parse(select.value));\n            this._changeGuard = false;\n        }\n    }\n    NotebookTools.KeySelector = KeySelector;\n    /**\n     * Create a slideshow selector.\n     */\n    function createSlideShowSelector(translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        trans.__('');\n        const options = {\n            key: 'slideshow',\n            title: trans.__('Slide Type'),\n            optionValueArray: [\n                ['-', null],\n                [trans.__('Slide'), 'slide'],\n                [trans.__('Sub-Slide'), 'subslide'],\n                [trans.__('Fragment'), 'fragment'],\n                [trans.__('Skip'), 'skip'],\n                [trans.__('Notes'), 'notes']\n            ],\n            getter: cell => {\n                const value = cell.model.metadata.get('slideshow');\n                return value && value['slide_type'];\n            },\n            setter: (cell, value) => {\n                let data = cell.model.metadata.get('slideshow') || Object.create(null);\n                if (value === null) {\n                    // Make a shallow copy so we aren't modifying the original metadata.\n                    data = Object.assign({}, data);\n                    delete data.slide_type;\n                }\n                else {\n                    data = Object.assign(Object.assign({}, data), { slide_type: value });\n                }\n                if (Object.keys(data).length > 0) {\n                    cell.model.metadata.set('slideshow', data);\n                }\n                else {\n                    cell.model.metadata.delete('slideshow');\n                }\n            }\n        };\n        return new KeySelector(options);\n    }\n    NotebookTools.createSlideShowSelector = createSlideShowSelector;\n    /**\n     * Create an nbconvert selector.\n     */\n    function createNBConvertSelector(optionValueArray, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        return new KeySelector({\n            key: 'raw_mimetype',\n            title: trans.__('Raw NBConvert Format'),\n            optionValueArray: optionValueArray,\n            validCellTypes: ['raw']\n        });\n    }\n    NotebookTools.createNBConvertSelector = createNBConvertSelector;\n})(NotebookTools || (NotebookTools = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A comparator function for widget rank items.\n     */\n    function itemCmp(first, second) {\n        return first.rank - second.rank;\n    }\n    Private.itemCmp = itemCmp;\n    /**\n     * Create the node for a KeySelector.\n     */\n    function createSelectorNode(options) {\n        const name = options.key;\n        const title = options.title || name[0].toLocaleUpperCase() + name.slice(1);\n        const optionNodes = [];\n        let value;\n        let option;\n        each(options.optionValueArray, item => {\n            option = item[0];\n            value = JSON.stringify(item[1]);\n            optionNodes.push(h.option({ value }, option));\n        });\n        const node = VirtualDOM.realize(h.div({}, h.label(title, h.select({}, optionNodes))));\n        Styling.styleNode(node);\n        return node;\n    }\n    Private.createSelectorNode = createSelectorNode;\n})(Private || (Private = {}));\n//# sourceMappingURL=notebooktools.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ArrayExt, each } from '@lumino/algorithm';\nimport { MimeData } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\nimport { Signal } from '@lumino/signaling';\nimport { Drag } from '@lumino/dragdrop';\nimport { PanelLayout, Widget } from '@lumino/widgets';\nimport { h, VirtualDOM } from '@lumino/virtualdom';\nimport { ElementExt } from '@lumino/domutils';\nimport { Cell, CodeCell, MarkdownCell, RawCell } from '@jupyterlab/cells';\nimport { CodeEditor } from '@jupyterlab/codeeditor';\n/**\n * The data attribute added to a widget that has an active kernel.\n */\nconst KERNEL_USER = 'jpKernelUser';\n/**\n * The data attribute added to a widget that can run code.\n */\nconst CODE_RUNNER = 'jpCodeRunner';\n/**\n * The data attribute added to a widget that can undo.\n */\nconst UNDOER = 'jpUndoer';\n/**\n * The class name added to notebook widgets.\n */\nconst NB_CLASS = 'jp-Notebook';\n/**\n * The class name added to notebook widget cells.\n */\nconst NB_CELL_CLASS = 'jp-Notebook-cell';\n/**\n * The class name added to a notebook in edit mode.\n */\nconst EDIT_CLASS = 'jp-mod-editMode';\n/**\n * The class name added to a notebook in command mode.\n */\nconst COMMAND_CLASS = 'jp-mod-commandMode';\n/**\n * The class name added to the active cell.\n */\nconst ACTIVE_CLASS = 'jp-mod-active';\n/**\n * The class name added to selected cells.\n */\nconst SELECTED_CLASS = 'jp-mod-selected';\n/**\n * The class name added to an active cell when there are other selected cells.\n */\nconst OTHER_SELECTED_CLASS = 'jp-mod-multiSelected';\n/**\n * The class name added to unconfined images.\n */\nconst UNCONFINED_CLASS = 'jp-mod-unconfined';\n/**\n * The class name added to a drop target.\n */\nconst DROP_TARGET_CLASS = 'jp-mod-dropTarget';\n/**\n * The class name added to a drop source.\n */\nconst DROP_SOURCE_CLASS = 'jp-mod-dropSource';\n/**\n * The class name added to drag images.\n */\nconst DRAG_IMAGE_CLASS = 'jp-dragImage';\n/**\n * The class name added to singular drag images\n */\nconst SINGLE_DRAG_IMAGE_CLASS = 'jp-dragImage-singlePrompt';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_CONTENT_CLASS = 'jp-dragImage-content';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_PROMPT_CLASS = 'jp-dragImage-prompt';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_MULTIPLE_BACK = 'jp-dragImage-multipleBack';\n/**\n * The mimetype used for Jupyter cell data.\n */\nconst JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';\n/**\n * The threshold in pixels to start a drag event.\n */\nconst DRAG_THRESHOLD = 5;\n/**\n * A widget which renders static non-interactive notebooks.\n *\n * #### Notes\n * The widget model must be set separately and can be changed\n * at any time.  Consumers of the widget must account for a\n * `null` model, and may want to listen to the `modelChanged`\n * signal.\n */\nexport class StaticNotebook extends Widget {\n    /**\n     * Construct a notebook widget.\n     */\n    constructor(options) {\n        super();\n        this._editorConfig = StaticNotebook.defaultEditorConfig;\n        this._notebookConfig = StaticNotebook.defaultNotebookConfig;\n        this._mimetype = 'text/plain';\n        this._model = null;\n        this._modelChanged = new Signal(this);\n        this._modelContentChanged = new Signal(this);\n        this.addClass(NB_CLASS);\n        this.node.dataset[KERNEL_USER] = 'true';\n        this.node.dataset[UNDOER] = 'true';\n        this.rendermime = options.rendermime;\n        this.layout = new Private.NotebookPanelLayout();\n        this.contentFactory =\n            options.contentFactory || StaticNotebook.defaultContentFactory;\n        this.editorConfig =\n            options.editorConfig || StaticNotebook.defaultEditorConfig;\n        this.notebookConfig =\n            options.notebookConfig || StaticNotebook.defaultNotebookConfig;\n        this._mimetypeService = options.mimeTypeService;\n    }\n    /**\n     * A signal emitted when the model of the notebook changes.\n     */\n    get modelChanged() {\n        return this._modelChanged;\n    }\n    /**\n     * A signal emitted when the model content changes.\n     *\n     * #### Notes\n     * This is a convenience signal that follows the current model.\n     */\n    get modelContentChanged() {\n        return this._modelContentChanged;\n    }\n    /**\n     * The model for the widget.\n     */\n    get model() {\n        return this._model;\n    }\n    set model(newValue) {\n        newValue = newValue || null;\n        if (this._model === newValue) {\n            return;\n        }\n        const oldValue = this._model;\n        this._model = newValue;\n        if (oldValue && oldValue.modelDB.isCollaborative) {\n            void oldValue.modelDB.connected.then(() => {\n                oldValue.modelDB.collaborators.changed.disconnect(this._onCollaboratorsChanged, this);\n            });\n        }\n        if (newValue && newValue.modelDB.isCollaborative) {\n            void newValue.modelDB.connected.then(() => {\n                newValue.modelDB.collaborators.changed.connect(this._onCollaboratorsChanged, this);\n            });\n        }\n        // Trigger private, protected, and public changes.\n        this._onModelChanged(oldValue, newValue);\n        this.onModelChanged(oldValue, newValue);\n        this._modelChanged.emit(void 0);\n    }\n    /**\n     * Get the mimetype for code cells.\n     */\n    get codeMimetype() {\n        return this._mimetype;\n    }\n    /**\n     * A read-only sequence of the widgets in the notebook.\n     */\n    get widgets() {\n        return this.layout.widgets;\n    }\n    /**\n     * A configuration object for cell editor settings.\n     */\n    get editorConfig() {\n        return this._editorConfig;\n    }\n    set editorConfig(value) {\n        this._editorConfig = value;\n        this._updateEditorConfig();\n    }\n    /**\n     * A configuration object for notebook settings.\n     */\n    get notebookConfig() {\n        return this._notebookConfig;\n    }\n    set notebookConfig(value) {\n        this._notebookConfig = value;\n        this._updateNotebookConfig();\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        // Do nothing if already disposed.\n        if (this.isDisposed) {\n            return;\n        }\n        this._model = null;\n        super.dispose();\n    }\n    /**\n     * Handle a new model.\n     *\n     * #### Notes\n     * This method is called after the model change has been handled\n     * internally and before the `modelChanged` signal is emitted.\n     * The default implementation is a no-op.\n     */\n    onModelChanged(oldValue, newValue) {\n        // No-op.\n    }\n    /**\n     * Handle changes to the notebook model content.\n     *\n     * #### Notes\n     * The default implementation emits the `modelContentChanged` signal.\n     */\n    onModelContentChanged(model, args) {\n        this._modelContentChanged.emit(void 0);\n    }\n    /**\n     * Handle changes to the notebook model metadata.\n     *\n     * #### Notes\n     * The default implementation updates the mimetypes of the code cells\n     * when the `language_info` metadata changes.\n     */\n    onMetadataChanged(sender, args) {\n        switch (args.key) {\n            case 'language_info':\n                this._updateMimetype();\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle a cell being inserted.\n     *\n     * The default implementation is a no-op\n     */\n    onCellInserted(index, cell) {\n        // This is a no-op.\n    }\n    /**\n     * Handle a cell being moved.\n     *\n     * The default implementation is a no-op\n     */\n    onCellMoved(fromIndex, toIndex) {\n        // This is a no-op.\n    }\n    /**\n     * Handle a cell being removed.\n     *\n     * The default implementation is a no-op\n     */\n    onCellRemoved(index, cell) {\n        // This is a no-op.\n    }\n    /**\n     * Handle a new model on the widget.\n     */\n    _onModelChanged(oldValue, newValue) {\n        const layout = this.layout;\n        if (oldValue) {\n            oldValue.cells.changed.disconnect(this._onCellsChanged, this);\n            oldValue.metadata.changed.disconnect(this.onMetadataChanged, this);\n            oldValue.contentChanged.disconnect(this.onModelContentChanged, this);\n            // TODO: reuse existing cell widgets if possible. Remember to initially\n            // clear the history of each cell if we do this.\n            while (layout.widgets.length) {\n                this._removeCell(0);\n            }\n        }\n        if (!newValue) {\n            this._mimetype = 'text/plain';\n            return;\n        }\n        this._updateMimetype();\n        const cells = newValue.cells;\n        // If there are no cells, create an empty cell\n        if (!cells.length) {\n            cells.push(newValue.contentFactory.createCell(this.notebookConfig.defaultCell, {}));\n        }\n        each(cells, (cell, i) => {\n            this._insertCell(i, cell);\n        });\n        cells.changed.connect(this._onCellsChanged, this);\n        newValue.contentChanged.connect(this.onModelContentChanged, this);\n        newValue.metadata.changed.connect(this.onMetadataChanged, this);\n    }\n    /**\n     * Handle a change cells event.\n     */\n    _onCellsChanged(sender, args) {\n        let index = 0;\n        switch (args.type) {\n            case 'add':\n                index = args.newIndex;\n                each(args.newValues, value => {\n                    this._insertCell(index++, value);\n                });\n                break;\n            case 'move':\n                this._moveCell(args.oldIndex, args.newIndex);\n                break;\n            case 'remove':\n                each(args.oldValues, value => {\n                    this._removeCell(args.oldIndex);\n                });\n                // Add default cell if there are no cells remaining.\n                if (!sender.length) {\n                    const model = this.model;\n                    // Add the cell in a new context to avoid triggering another\n                    // cell changed event during the handling of this signal.\n                    requestAnimationFrame(() => {\n                        if (model && !model.isDisposed && !model.cells.length) {\n                            model.cells.push(model.contentFactory.createCell(this.notebookConfig.defaultCell, {}));\n                        }\n                    });\n                }\n                break;\n            case 'set':\n                // TODO: reuse existing widgets if possible.\n                index = args.newIndex;\n                each(args.newValues, value => {\n                    // Note: this ordering (insert then remove)\n                    // is important for getting the active cell\n                    // index for the editable notebook correct.\n                    this._insertCell(index, value);\n                    this._removeCell(index + 1);\n                    index++;\n                });\n                break;\n            default:\n                return;\n        }\n    }\n    /**\n     * Create a cell widget and insert into the notebook.\n     */\n    _insertCell(index, cell) {\n        let widget;\n        switch (cell.type) {\n            case 'code':\n                widget = this._createCodeCell(cell);\n                widget.model.mimeType = this._mimetype;\n                break;\n            case 'markdown':\n                widget = this._createMarkdownCell(cell);\n                if (cell.value.text === '') {\n                    widget.rendered = false;\n                }\n                break;\n            default:\n                widget = this._createRawCell(cell);\n        }\n        widget.addClass(NB_CELL_CLASS);\n        const layout = this.layout;\n        layout.insertWidget(index, widget);\n        this.onCellInserted(index, widget);\n    }\n    /**\n     * Create a code cell widget from a code cell model.\n     */\n    _createCodeCell(model) {\n        const rendermime = this.rendermime;\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.code;\n        const options = {\n            editorConfig,\n            model,\n            rendermime,\n            contentFactory,\n            updateEditorOnShow: false\n        };\n        const cell = this.contentFactory.createCodeCell(options, this);\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        cell.syncScrolled = true;\n        return cell;\n    }\n    /**\n     * Create a markdown cell widget from a markdown cell model.\n     */\n    _createMarkdownCell(model) {\n        const rendermime = this.rendermime;\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.markdown;\n        const options = {\n            editorConfig,\n            model,\n            rendermime,\n            contentFactory,\n            updateEditorOnShow: false\n        };\n        const cell = this.contentFactory.createMarkdownCell(options, this);\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        return cell;\n    }\n    /**\n     * Create a raw cell widget from a raw cell model.\n     */\n    _createRawCell(model) {\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.raw;\n        const options = {\n            editorConfig,\n            model,\n            contentFactory,\n            updateEditorOnShow: false\n        };\n        const cell = this.contentFactory.createRawCell(options, this);\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        return cell;\n    }\n    /**\n     * Move a cell widget.\n     */\n    _moveCell(fromIndex, toIndex) {\n        const layout = this.layout;\n        layout.insertWidget(toIndex, layout.widgets[fromIndex]);\n        this.onCellMoved(fromIndex, toIndex);\n    }\n    /**\n     * Remove a cell widget.\n     */\n    _removeCell(index) {\n        const layout = this.layout;\n        const widget = layout.widgets[index];\n        widget.parent = null;\n        this.onCellRemoved(index, widget);\n        widget.dispose();\n    }\n    /**\n     * Update the mimetype of the notebook.\n     */\n    _updateMimetype() {\n        var _a;\n        const info = (_a = this._model) === null || _a === void 0 ? void 0 : _a.metadata.get('language_info');\n        if (!info) {\n            return;\n        }\n        this._mimetype = this._mimetypeService.getMimeTypeByLanguage(info);\n        each(this.widgets, widget => {\n            if (widget.model.type === 'code') {\n                widget.model.mimeType = this._mimetype;\n            }\n        });\n    }\n    /**\n     * Handle an update to the collaborators.\n     */\n    _onCollaboratorsChanged() {\n        var _a, _b, _c;\n        // If there are selections corresponding to non-collaborators,\n        // they are stale and should be removed.\n        for (let i = 0; i < this.widgets.length; i++) {\n            const cell = this.widgets[i];\n            for (const key of cell.model.selections.keys()) {\n                if (false === ((_c = (_b = (_a = this._model) === null || _a === void 0 ? void 0 : _a.modelDB) === null || _b === void 0 ? void 0 : _b.collaborators) === null || _c === void 0 ? void 0 : _c.has(key))) {\n                    cell.model.selections.delete(key);\n                }\n            }\n        }\n    }\n    /**\n     * Update editor settings for notebook cells.\n     */\n    _updateEditorConfig() {\n        for (let i = 0; i < this.widgets.length; i++) {\n            const cell = this.widgets[i];\n            let config;\n            switch (cell.model.type) {\n                case 'code':\n                    config = this._editorConfig.code;\n                    break;\n                case 'markdown':\n                    config = this._editorConfig.markdown;\n                    break;\n                default:\n                    config = this._editorConfig.raw;\n                    break;\n            }\n            Object.keys(config).forEach((key) => {\n                var _a;\n                cell.editor.setOption(key, (_a = config[key]) !== null && _a !== void 0 ? _a : null);\n            });\n            cell.editor.refresh();\n        }\n    }\n    /**\n     * Apply updated notebook settings.\n     */\n    _updateNotebookConfig() {\n        // Apply scrollPastEnd setting.\n        this.toggleClass('jp-mod-scrollPastEnd', this._notebookConfig.scrollPastEnd);\n    }\n}\n/**\n * The namespace for the `StaticNotebook` class statics.\n */\n(function (StaticNotebook) {\n    /**\n     * Default configuration options for cell editors.\n     */\n    StaticNotebook.defaultEditorConfig = {\n        code: Object.assign(Object.assign({}, CodeEditor.defaultConfig), { lineWrap: 'off', matchBrackets: true, autoClosingBrackets: true }),\n        markdown: Object.assign(Object.assign({}, CodeEditor.defaultConfig), { lineWrap: 'on', matchBrackets: false, autoClosingBrackets: false }),\n        raw: Object.assign(Object.assign({}, CodeEditor.defaultConfig), { lineWrap: 'on', matchBrackets: false, autoClosingBrackets: false })\n    };\n    /**\n     * Default configuration options for notebooks.\n     */\n    StaticNotebook.defaultNotebookConfig = {\n        scrollPastEnd: true,\n        defaultCell: 'code',\n        recordTiming: false\n    };\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory extends Cell.ContentFactory {\n        /**\n         * Create a new code cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createCodeCell(options, parent) {\n            if (!options.contentFactory) {\n                options.contentFactory = this;\n            }\n            return new CodeCell(options).initializeState();\n        }\n        /**\n         * Create a new markdown cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createMarkdownCell(options, parent) {\n            if (!options.contentFactory) {\n                options.contentFactory = this;\n            }\n            return new MarkdownCell(options).initializeState();\n        }\n        /**\n         * Create a new raw cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createRawCell(options, parent) {\n            if (!options.contentFactory) {\n                options.contentFactory = this;\n            }\n            return new RawCell(options).initializeState();\n        }\n    }\n    StaticNotebook.ContentFactory = ContentFactory;\n    /**\n     * Default content factory for the static notebook widget.\n     */\n    StaticNotebook.defaultContentFactory = new ContentFactory();\n})(StaticNotebook || (StaticNotebook = {}));\n/**\n * A notebook widget that supports interactivity.\n */\nexport class Notebook extends StaticNotebook {\n    /**\n     * Construct a notebook widget.\n     */\n    constructor(options) {\n        super(Private.processNotebookOptions(options));\n        this._activeCellIndex = -1;\n        this._activeCell = null;\n        this._mode = 'command';\n        this._drag = null;\n        this._fragment = '';\n        this._dragData = null;\n        this._mouseMode = null;\n        this._activeCellChanged = new Signal(this);\n        this._stateChanged = new Signal(this);\n        this._selectionChanged = new Signal(this);\n        this._checkCacheOnNextResize = false;\n        this.node.tabIndex = -1; // Allow the widget to take focus.\n        // Allow the node to scroll while dragging items.\n        this.node.setAttribute('data-lm-dragscroll', 'true');\n    }\n    /**\n     * A signal emitted when the active cell changes.\n     *\n     * #### Notes\n     * This can be due to the active index changing or the\n     * cell at the active index changing.\n     */\n    get activeCellChanged() {\n        return this._activeCellChanged;\n    }\n    /**\n     * A signal emitted when the state of the notebook changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * A signal emitted when the selection state of the notebook changes.\n     */\n    get selectionChanged() {\n        return this._selectionChanged;\n    }\n    /**\n     * The interactivity mode of the notebook.\n     */\n    get mode() {\n        return this._mode;\n    }\n    set mode(newValue) {\n        const activeCell = this.activeCell;\n        if (!activeCell) {\n            newValue = 'command';\n        }\n        if (newValue === this._mode) {\n            this._ensureFocus();\n            return;\n        }\n        // Post an update request.\n        this.update();\n        const oldValue = this._mode;\n        this._mode = newValue;\n        if (newValue === 'edit') {\n            // Edit mode deselects all cells.\n            each(this.widgets, widget => {\n                this.deselect(widget);\n            });\n            //  Edit mode unrenders an active markdown widget.\n            if (activeCell instanceof MarkdownCell) {\n                activeCell.rendered = false;\n            }\n            activeCell.inputHidden = false;\n        }\n        else {\n            // Focus on the notebook document, which blurs the active cell.\n            this.node.focus();\n        }\n        this._stateChanged.emit({ name: 'mode', oldValue, newValue });\n        this._ensureFocus();\n    }\n    /**\n     * The active cell index of the notebook.\n     *\n     * #### Notes\n     * The index will be clamped to the bounds of the notebook cells.\n     */\n    get activeCellIndex() {\n        if (!this.model) {\n            return -1;\n        }\n        return this.model.cells.length ? this._activeCellIndex : -1;\n    }\n    set activeCellIndex(newValue) {\n        const oldValue = this._activeCellIndex;\n        if (!this.model || !this.model.cells.length) {\n            newValue = -1;\n        }\n        else {\n            newValue = Math.max(newValue, 0);\n            newValue = Math.min(newValue, this.model.cells.length - 1);\n        }\n        this._activeCellIndex = newValue;\n        const cell = this.widgets[newValue];\n        if (cell !== this._activeCell) {\n            // Post an update request.\n            this.update();\n            this._activeCell = cell;\n            this._activeCellChanged.emit(cell);\n        }\n        if (this.mode === 'edit' && cell instanceof MarkdownCell) {\n            cell.rendered = false;\n        }\n        this._ensureFocus();\n        if (newValue === oldValue) {\n            return;\n        }\n        this._trimSelections();\n        this._stateChanged.emit({ name: 'activeCellIndex', oldValue, newValue });\n    }\n    /**\n     * Get the active cell widget.\n     *\n     * #### Notes\n     * This is a cell or `null` if there is no active cell.\n     */\n    get activeCell() {\n        return this._activeCell;\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._activeCell = null;\n        super.dispose();\n    }\n    /**\n     * Select a cell widget.\n     *\n     * #### Notes\n     * It is a no-op if the value does not change.\n     * It will emit the `selectionChanged` signal.\n     */\n    select(widget) {\n        if (Private.selectedProperty.get(widget)) {\n            return;\n        }\n        Private.selectedProperty.set(widget, true);\n        this._selectionChanged.emit(void 0);\n        this.update();\n    }\n    /**\n     * Deselect a cell widget.\n     *\n     * #### Notes\n     * It is a no-op if the value does not change.\n     * It will emit the `selectionChanged` signal.\n     */\n    deselect(widget) {\n        if (!Private.selectedProperty.get(widget)) {\n            return;\n        }\n        Private.selectedProperty.set(widget, false);\n        this._selectionChanged.emit(void 0);\n        this.update();\n    }\n    /**\n     * Whether a cell is selected.\n     */\n    isSelected(widget) {\n        return Private.selectedProperty.get(widget);\n    }\n    /**\n     * Whether a cell is selected or is the active cell.\n     */\n    isSelectedOrActive(widget) {\n        if (widget === this._activeCell) {\n            return true;\n        }\n        return Private.selectedProperty.get(widget);\n    }\n    /**\n     * Deselect all of the cells.\n     */\n    deselectAll() {\n        let changed = false;\n        each(this.widgets, widget => {\n            if (Private.selectedProperty.get(widget)) {\n                changed = true;\n            }\n            Private.selectedProperty.set(widget, false);\n        });\n        if (changed) {\n            this._selectionChanged.emit(void 0);\n        }\n        // Make sure we have a valid active cell.\n        this.activeCellIndex = this.activeCellIndex; // eslint-disable-line\n        this.update();\n    }\n    /**\n     * Move the head of an existing contiguous selection to extend the selection.\n     *\n     * @param index - The new head of the existing selection.\n     *\n     * #### Notes\n     * If there is no existing selection, the active cell is considered an\n     * existing one-cell selection.\n     *\n     * If the new selection is a single cell, that cell becomes the active cell\n     * and all cells are deselected.\n     *\n     * There is no change if there are no cells (i.e., activeCellIndex is -1).\n     */\n    extendContiguousSelectionTo(index) {\n        let { head, anchor } = this.getContiguousSelection();\n        let i;\n        // Handle the case of no current selection.\n        if (anchor === null || head === null) {\n            if (index === this.activeCellIndex) {\n                // Already collapsed selection, nothing more to do.\n                return;\n            }\n            // We will start a new selection below.\n            head = this.activeCellIndex;\n            anchor = this.activeCellIndex;\n        }\n        // Move the active cell. We do this before the collapsing shortcut below.\n        this.activeCellIndex = index;\n        // Make sure the index is valid, according to the rules for setting and clipping the\n        // active cell index. This may change the index.\n        index = this.activeCellIndex;\n        // Collapse the selection if it is only the active cell.\n        if (index === anchor) {\n            this.deselectAll();\n            return;\n        }\n        let selectionChanged = false;\n        if (head < index) {\n            if (head < anchor) {\n                Private.selectedProperty.set(this.widgets[head], false);\n                selectionChanged = true;\n            }\n            // Toggle everything strictly between head and index except anchor.\n            for (i = head + 1; i < index; i++) {\n                if (i !== anchor) {\n                    Private.selectedProperty.set(this.widgets[i], !Private.selectedProperty.get(this.widgets[i]));\n                    selectionChanged = true;\n                }\n            }\n        }\n        else if (index < head) {\n            if (anchor < head) {\n                Private.selectedProperty.set(this.widgets[head], false);\n                selectionChanged = true;\n            }\n            // Toggle everything strictly between index and head except anchor.\n            for (i = index + 1; i < head; i++) {\n                if (i !== anchor) {\n                    Private.selectedProperty.set(this.widgets[i], !Private.selectedProperty.get(this.widgets[i]));\n                    selectionChanged = true;\n                }\n            }\n        }\n        // Anchor and index should *always* be selected.\n        if (!Private.selectedProperty.get(this.widgets[anchor])) {\n            selectionChanged = true;\n        }\n        Private.selectedProperty.set(this.widgets[anchor], true);\n        if (!Private.selectedProperty.get(this.widgets[index])) {\n            selectionChanged = true;\n        }\n        Private.selectedProperty.set(this.widgets[index], true);\n        if (selectionChanged) {\n            this._selectionChanged.emit(void 0);\n        }\n    }\n    /**\n     * Get the head and anchor of a contiguous cell selection.\n     *\n     * The head of a contiguous selection is always the active cell.\n     *\n     * If there are no cells selected, `{head: null, anchor: null}` is returned.\n     *\n     * Throws an error if the currently selected cells do not form a contiguous\n     * selection.\n     */\n    getContiguousSelection() {\n        const cells = this.widgets;\n        const first = ArrayExt.findFirstIndex(cells, c => this.isSelected(c));\n        // Return early if no cells are selected.\n        if (first === -1) {\n            return { head: null, anchor: null };\n        }\n        const last = ArrayExt.findLastIndex(cells, c => this.isSelected(c), -1, first);\n        // Check that the selection is contiguous.\n        for (let i = first; i <= last; i++) {\n            if (!this.isSelected(cells[i])) {\n                throw new Error('Selection not contiguous');\n            }\n        }\n        // Check that the active cell is one of the endpoints of the selection.\n        const activeIndex = this.activeCellIndex;\n        if (first !== activeIndex && last !== activeIndex) {\n            throw new Error('Active cell not at endpoint of selection');\n        }\n        // Determine the head and anchor of the selection.\n        if (first === activeIndex) {\n            return { head: first, anchor: last };\n        }\n        else {\n            return { head: last, anchor: first };\n        }\n    }\n    /**\n     * Scroll so that the given position is centered.\n     *\n     * @param position - The vertical position in the notebook widget.\n     *\n     * @param threshold - An optional threshold for the scroll (0-50, defaults to\n     * 25).\n     *\n     * #### Notes\n     * If the position is within the threshold percentage of the widget height,\n     * measured from the center of the widget, the scroll position will not be\n     * changed. A threshold of 0 means we will always scroll so the position is\n     * centered, and a threshold of 50 means scrolling only happens if position is\n     * outside the current window.\n     */\n    scrollToPosition(position, threshold = 25) {\n        const node = this.node;\n        const ar = node.getBoundingClientRect();\n        const delta = position - ar.top - ar.height / 2;\n        if (Math.abs(delta) > (ar.height * threshold) / 100) {\n            node.scrollTop += delta;\n        }\n    }\n    /**\n     * Scroll so that the given cell is in view. Selects and activates cell.\n     *\n     * @param cell - A cell in the notebook widget.\n     *\n     */\n    scrollToCell(cell) {\n        // use Phosphor to scroll\n        ElementExt.scrollIntoViewIfNeeded(this.node, cell.node);\n        // change selection and active cell:\n        this.deselectAll();\n        this.select(cell);\n        cell.activate();\n    }\n    /**\n     * Set URI fragment identifier.\n     */\n    setFragment(fragment) {\n        // Wait all cells are rendered then set fragment and update.\n        void Promise.all(this.widgets.map(widget => widget.ready)).then(() => {\n            this._fragment = fragment;\n            this.update();\n        });\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the notebook panel's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        if (!this.model) {\n            return;\n        }\n        switch (event.type) {\n            case 'contextmenu':\n                if (event.eventPhase === Event.CAPTURING_PHASE) {\n                    this._evtContextMenuCapture(event);\n                }\n                break;\n            case 'mousedown':\n                if (event.eventPhase === Event.CAPTURING_PHASE) {\n                    this._evtMouseDownCapture(event);\n                }\n                else {\n                    this._evtMouseDown(event);\n                }\n                break;\n            case 'mouseup':\n                if (event.currentTarget === document) {\n                    this._evtDocumentMouseup(event);\n                }\n                break;\n            case 'mousemove':\n                if (event.currentTarget === document) {\n                    this._evtDocumentMousemove(event);\n                }\n                break;\n            case 'keydown':\n                this._ensureFocus(true);\n                break;\n            case 'dblclick':\n                this._evtDblClick(event);\n                break;\n            case 'focusin':\n                this._evtFocusIn(event);\n                break;\n            case 'focusout':\n                this._evtFocusOut(event);\n                break;\n            case 'lm-dragenter':\n                this._evtDragEnter(event);\n                break;\n            case 'lm-dragleave':\n                this._evtDragLeave(event);\n                break;\n            case 'lm-dragover':\n                this._evtDragOver(event);\n                break;\n            case 'lm-drop':\n                this._evtDrop(event);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle `after-attach` messages for the widget.\n     */\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        const node = this.node;\n        node.addEventListener('contextmenu', this, true);\n        node.addEventListener('mousedown', this, true);\n        node.addEventListener('mousedown', this);\n        node.addEventListener('keydown', this);\n        node.addEventListener('dblclick', this);\n        node.addEventListener('focusin', this);\n        node.addEventListener('focusout', this);\n        // Capture drag events for the notebook widget\n        // in order to preempt the drag/drop handlers in the\n        // code editor widgets, which can take text data.\n        node.addEventListener('lm-dragenter', this, true);\n        node.addEventListener('lm-dragleave', this, true);\n        node.addEventListener('lm-dragover', this, true);\n        node.addEventListener('lm-drop', this, true);\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        const node = this.node;\n        node.removeEventListener('contextmenu', this, true);\n        node.removeEventListener('mousedown', this, true);\n        node.removeEventListener('mousedown', this);\n        node.removeEventListener('keydown', this);\n        node.removeEventListener('dblclick', this);\n        node.removeEventListener('focusin', this);\n        node.removeEventListener('focusout', this);\n        node.removeEventListener('lm-dragenter', this, true);\n        node.removeEventListener('lm-dragleave', this, true);\n        node.removeEventListener('lm-dragover', this, true);\n        node.removeEventListener('lm-drop', this, true);\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n    }\n    /**\n     * A message handler invoked on an `'after-show'` message.\n     */\n    onAfterShow(msg) {\n        this._checkCacheOnNextResize = true;\n    }\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    onResize(msg) {\n        if (!this._checkCacheOnNextResize) {\n            return super.onResize(msg);\n        }\n        this._checkCacheOnNextResize = false;\n        const cache = this._cellLayoutStateCache;\n        const width = parseInt(this.node.style.width, 10);\n        if (cache) {\n            if (width === cache.width) {\n                // Cache identical, do nothing\n                return;\n            }\n        }\n        // Update cache\n        this._cellLayoutStateCache = { width };\n        // Fallback:\n        for (const w of this.widgets) {\n            if (w instanceof Cell) {\n                w.editorWidget.update();\n            }\n        }\n    }\n    /**\n     * A message handler invoked on an `'before-hide'` message.\n     */\n    onBeforeHide(msg) {\n        // Update cache\n        const width = parseInt(this.node.style.width, 10);\n        this._cellLayoutStateCache = { width };\n    }\n    /**\n     * Handle `'activate-request'` messages.\n     */\n    onActivateRequest(msg) {\n        this._ensureFocus(true);\n    }\n    /**\n     * Handle `update-request` messages sent to the widget.\n     */\n    onUpdateRequest(msg) {\n        const activeCell = this.activeCell;\n        // Set the appropriate classes on the cells.\n        if (this.mode === 'edit') {\n            this.addClass(EDIT_CLASS);\n            this.removeClass(COMMAND_CLASS);\n        }\n        else {\n            this.addClass(COMMAND_CLASS);\n            this.removeClass(EDIT_CLASS);\n        }\n        if (activeCell) {\n            activeCell.addClass(ACTIVE_CLASS);\n        }\n        let count = 0;\n        each(this.widgets, widget => {\n            if (widget !== activeCell) {\n                widget.removeClass(ACTIVE_CLASS);\n            }\n            widget.removeClass(OTHER_SELECTED_CLASS);\n            if (this.isSelectedOrActive(widget)) {\n                widget.addClass(SELECTED_CLASS);\n                count++;\n            }\n            else {\n                widget.removeClass(SELECTED_CLASS);\n            }\n        });\n        if (count > 1) {\n            activeCell === null || activeCell === void 0 ? void 0 : activeCell.addClass(OTHER_SELECTED_CLASS);\n        }\n        if (this._fragment) {\n            let el;\n            try {\n                el = this.node.querySelector(this._fragment);\n            }\n            catch (error) {\n                console.warn('Unable to set URI fragment identifier', error);\n            }\n            if (el) {\n                el.scrollIntoView();\n            }\n            this._fragment = '';\n        }\n    }\n    /**\n     * Handle a cell being inserted.\n     */\n    onCellInserted(index, cell) {\n        if (this.model && this.model.modelDB.isCollaborative) {\n            const modelDB = this.model.modelDB;\n            void modelDB.connected.then(() => {\n                if (!cell.isDisposed) {\n                    // Setup the selection style for collaborators.\n                    const localCollaborator = modelDB.collaborators.localCollaborator;\n                    cell.editor.uuid = localCollaborator.sessionId;\n                    cell.editor.selectionStyle = Object.assign(Object.assign({}, CodeEditor.defaultSelectionStyle), { color: localCollaborator.color });\n                }\n            });\n        }\n        cell.editor.edgeRequested.connect(this._onEdgeRequest, this);\n        // If the insertion happened above, increment the active cell\n        // index, otherwise it stays the same.\n        this.activeCellIndex =\n            index <= this.activeCellIndex\n                ? this.activeCellIndex + 1\n                : this.activeCellIndex;\n    }\n    /**\n     * Handle a cell being moved.\n     */\n    onCellMoved(fromIndex, toIndex) {\n        const i = this.activeCellIndex;\n        if (fromIndex === i) {\n            this.activeCellIndex = toIndex;\n        }\n        else if (fromIndex < i && i <= toIndex) {\n            this.activeCellIndex--;\n        }\n        else if (toIndex <= i && i < fromIndex) {\n            this.activeCellIndex++;\n        }\n    }\n    /**\n     * Handle a cell being removed.\n     */\n    onCellRemoved(index, cell) {\n        // If the removal happened above, decrement the active\n        // cell index, otherwise it stays the same.\n        this.activeCellIndex =\n            index <= this.activeCellIndex\n                ? this.activeCellIndex - 1\n                : this.activeCellIndex;\n        if (this.isSelected(cell)) {\n            this._selectionChanged.emit(void 0);\n        }\n    }\n    /**\n     * Handle a new model.\n     */\n    onModelChanged(oldValue, newValue) {\n        super.onModelChanged(oldValue, newValue);\n        // Try to set the active cell index to 0.\n        // It will be set to `-1` if there is no new model or the model is empty.\n        this.activeCellIndex = 0;\n    }\n    /**\n     * Handle edge request signals from cells.\n     */\n    _onEdgeRequest(editor, location) {\n        const prev = this.activeCellIndex;\n        if (location === 'top') {\n            this.activeCellIndex--;\n            // Move the cursor to the first position on the last line.\n            if (this.activeCellIndex < prev) {\n                const editor = this.activeCell.editor;\n                const lastLine = editor.lineCount - 1;\n                editor.setCursorPosition({ line: lastLine, column: 0 });\n            }\n        }\n        else if (location === 'bottom') {\n            this.activeCellIndex++;\n            // Move the cursor to the first character.\n            if (this.activeCellIndex > prev) {\n                const editor = this.activeCell.editor;\n                editor.setCursorPosition({ line: 0, column: 0 });\n            }\n        }\n        this.mode = 'edit';\n    }\n    /**\n     * Ensure that the notebook has proper focus.\n     */\n    _ensureFocus(force = false) {\n        const activeCell = this.activeCell;\n        if (this.mode === 'edit' && activeCell) {\n            if (!activeCell.editor.hasFocus()) {\n                activeCell.editor.focus();\n            }\n        }\n        if (force && !this.node.contains(document.activeElement)) {\n            this.node.focus();\n        }\n    }\n    /**\n     * Find the cell index containing the target html element.\n     *\n     * #### Notes\n     * Returns -1 if the cell is not found.\n     */\n    _findCell(node) {\n        // Trace up the DOM hierarchy to find the root cell node.\n        // Then find the corresponding child and select it.\n        let n = node;\n        while (n && n !== this.node) {\n            if (n.classList.contains(NB_CELL_CLASS)) {\n                const i = ArrayExt.findFirstIndex(this.widgets, widget => widget.node === n);\n                if (i !== -1) {\n                    return i;\n                }\n                break;\n            }\n            n = n.parentElement;\n        }\n        return -1;\n    }\n    /**\n     * Find the target of html mouse event and cell index containing this target.\n     *\n     * #### Notes\n     * Returned index is -1 if the cell is not found.\n     */\n    _findEventTargetAndCell(event) {\n        let target = event.target;\n        let index = this._findCell(target);\n        if (index === -1) {\n            // `event.target` sometimes gives an orphaned node in Firefox 57, which\n            // can have `null` anywhere in its parent line. If we fail to find a cell\n            // using `event.target`, try again using a target reconstructed from the\n            // position of the click event.\n            target = document.elementFromPoint(event.clientX, event.clientY);\n            index = this._findCell(target);\n        }\n        return [target, index];\n    }\n    /**\n     * Handle `contextmenu` event.\n     */\n    _evtContextMenuCapture(event) {\n        // Allow the event to propagate un-modified if the user\n        // is holding the shift-key (and probably requesting\n        // the native context menu).\n        if (event.shiftKey) {\n            return;\n        }\n        const [target, index] = this._findEventTargetAndCell(event);\n        const widget = this.widgets[index];\n        if (widget && widget.editorWidget.node.contains(target)) {\n            // Prevent CodeMirror from focusing the editor.\n            // TODO: find an editor-agnostic solution.\n            event.preventDefault();\n        }\n    }\n    /**\n     * Handle `mousedown` event in the capture phase for the widget.\n     */\n    _evtMouseDownCapture(event) {\n        const { button, shiftKey } = event;\n        const [target, index] = this._findEventTargetAndCell(event);\n        const widget = this.widgets[index];\n        // On OS X, the context menu may be triggered with ctrl-left-click. In\n        // Firefox, ctrl-left-click gives an event with button 2, but in Chrome,\n        // ctrl-left-click gives an event with button 0 with the ctrl modifier.\n        if (button === 2 &&\n            !shiftKey &&\n            widget &&\n            widget.editorWidget.node.contains(target)) {\n            this.mode = 'command';\n            // Prevent CodeMirror from focusing the editor.\n            // TODO: find an editor-agnostic solution.\n            event.preventDefault();\n        }\n    }\n    /**\n     * Handle `mousedown` events for the widget.\n     */\n    _evtMouseDown(event) {\n        var _a;\n        const { button, shiftKey } = event;\n        // We only handle main or secondary button actions.\n        if (!(button === 0 || button === 2)) {\n            return;\n        }\n        // Shift right-click gives the browser default behavior.\n        if (shiftKey && button === 2) {\n            return;\n        }\n        const [target, index] = this._findEventTargetAndCell(event);\n        const widget = this.widgets[index];\n        let targetArea;\n        if (widget) {\n            if (widget.editorWidget.node.contains(target)) {\n                targetArea = 'input';\n            }\n            else if (widget.promptNode.contains(target)) {\n                targetArea = 'prompt';\n            }\n            else {\n                targetArea = 'cell';\n            }\n        }\n        else {\n            targetArea = 'notebook';\n        }\n        // Make sure we go to command mode if the click isn't in the cell editor If\n        // we do click in the cell editor, the editor handles the focus event to\n        // switch to edit mode.\n        if (targetArea !== 'input') {\n            this.mode = 'command';\n        }\n        if (targetArea === 'notebook') {\n            this.deselectAll();\n        }\n        else if (targetArea === 'prompt' || targetArea === 'cell') {\n            // We don't want to prevent the default selection behavior\n            // if there is currently text selected in an output.\n            const hasSelection = ((_a = window.getSelection()) !== null && _a !== void 0 ? _a : '').toString() !== '';\n            if (button === 0 && shiftKey && !hasSelection) {\n                // Prevent browser selecting text in prompt or output\n                event.preventDefault();\n                // Shift-click - extend selection\n                try {\n                    this.extendContiguousSelectionTo(index);\n                }\n                catch (e) {\n                    console.error(e);\n                    this.deselectAll();\n                    return;\n                }\n                // Enter selecting mode\n                this._mouseMode = 'select';\n                document.addEventListener('mouseup', this, true);\n                document.addEventListener('mousemove', this, true);\n            }\n            else if (button === 0 && !shiftKey) {\n                // Prepare to start a drag if we are on the drag region.\n                if (targetArea === 'prompt') {\n                    // Prepare for a drag start\n                    this._dragData = {\n                        pressX: event.clientX,\n                        pressY: event.clientY,\n                        index: index\n                    };\n                    // Enter possible drag mode\n                    this._mouseMode = 'couldDrag';\n                    document.addEventListener('mouseup', this, true);\n                    document.addEventListener('mousemove', this, true);\n                    event.preventDefault();\n                }\n                if (!this.isSelectedOrActive(widget)) {\n                    this.deselectAll();\n                    this.activeCellIndex = index;\n                }\n            }\n            else if (button === 2) {\n                if (!this.isSelectedOrActive(widget)) {\n                    this.deselectAll();\n                    this.activeCellIndex = index;\n                }\n                event.preventDefault();\n            }\n        }\n        else if (targetArea === 'input') {\n            if (button === 2 && !this.isSelectedOrActive(widget)) {\n                this.deselectAll();\n                this.activeCellIndex = index;\n            }\n        }\n        // If we didn't set focus above, make sure we get focus now.\n        this._ensureFocus(true);\n    }\n    /**\n     * Handle the `'mouseup'` event on the document.\n     */\n    _evtDocumentMouseup(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        // Remove the event listeners we put on the document\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        if (this._mouseMode === 'couldDrag') {\n            // We didn't end up dragging if we are here, so treat it as a click event.\n            const [, index] = this._findEventTargetAndCell(event);\n            this.deselectAll();\n            this.activeCellIndex = index;\n        }\n        this._mouseMode = null;\n    }\n    /**\n     * Handle the `'mousemove'` event for the widget.\n     */\n    _evtDocumentMousemove(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        // If in select mode, update the selection\n        switch (this._mouseMode) {\n            case 'select': {\n                const target = event.target;\n                const index = this._findCell(target);\n                if (index !== -1) {\n                    this.extendContiguousSelectionTo(index);\n                }\n                break;\n            }\n            case 'couldDrag': {\n                // Check for a drag initialization.\n                const data = this._dragData;\n                const dx = Math.abs(event.clientX - data.pressX);\n                const dy = Math.abs(event.clientY - data.pressY);\n                if (dx >= DRAG_THRESHOLD || dy >= DRAG_THRESHOLD) {\n                    this._mouseMode = null;\n                    this._startDrag(data.index, event.clientX, event.clientY);\n                }\n                break;\n            }\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle the `'lm-dragenter'` event for the widget.\n     */\n    _evtDragEnter(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        const target = event.target;\n        const index = this._findCell(target);\n        if (index === -1) {\n            return;\n        }\n        const widget = this.layout.widgets[index];\n        widget.node.classList.add(DROP_TARGET_CLASS);\n    }\n    /**\n     * Handle the `'lm-dragleave'` event for the widget.\n     */\n    _evtDragLeave(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        const elements = this.node.getElementsByClassName(DROP_TARGET_CLASS);\n        if (elements.length) {\n            elements[0].classList.remove(DROP_TARGET_CLASS);\n        }\n    }\n    /**\n     * Handle the `'lm-dragover'` event for the widget.\n     */\n    _evtDragOver(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        event.dropAction = event.proposedAction;\n        const elements = this.node.getElementsByClassName(DROP_TARGET_CLASS);\n        if (elements.length) {\n            elements[0].classList.remove(DROP_TARGET_CLASS);\n        }\n        const target = event.target;\n        const index = this._findCell(target);\n        if (index === -1) {\n            return;\n        }\n        const widget = this.layout.widgets[index];\n        widget.node.classList.add(DROP_TARGET_CLASS);\n    }\n    /**\n     * Handle the `'lm-drop'` event for the widget.\n     */\n    _evtDrop(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        if (event.proposedAction === 'none') {\n            event.dropAction = 'none';\n            return;\n        }\n        let target = event.target;\n        while (target && target.parentElement) {\n            if (target.classList.contains(DROP_TARGET_CLASS)) {\n                target.classList.remove(DROP_TARGET_CLASS);\n                break;\n            }\n            target = target.parentElement;\n        }\n        // Model presence should be checked before calling event handlers\n        const model = this.model;\n        const source = event.source;\n        if (source === this) {\n            // Handle the case where we are moving cells within\n            // the same notebook.\n            event.dropAction = 'move';\n            const toMove = event.mimeData.getData('internal:cells');\n            // Compute the to/from indices for the move.\n            let fromIndex = ArrayExt.firstIndexOf(this.widgets, toMove[0]);\n            let toIndex = this._findCell(target);\n            // This check is needed for consistency with the view.\n            if (toIndex !== -1 && toIndex > fromIndex) {\n                toIndex -= 1;\n            }\n            else if (toIndex === -1) {\n                // If the drop is within the notebook but not on any cell,\n                // most often this means it is past the cell areas, so\n                // set it to move the cells to the end of the notebook.\n                toIndex = this.widgets.length - 1;\n            }\n            // Don't move if we are within the block of selected cells.\n            if (toIndex >= fromIndex && toIndex < fromIndex + toMove.length) {\n                return;\n            }\n            // Move the cells one by one\n            model.cells.beginCompoundOperation();\n            if (fromIndex < toIndex) {\n                each(toMove, cellWidget => {\n                    model.cells.move(fromIndex, toIndex);\n                });\n            }\n            else if (fromIndex > toIndex) {\n                each(toMove, cellWidget => {\n                    model.cells.move(fromIndex++, toIndex++);\n                });\n            }\n            model.cells.endCompoundOperation();\n        }\n        else {\n            // Handle the case where we are copying cells between\n            // notebooks.\n            event.dropAction = 'copy';\n            // Find the target cell and insert the copied cells.\n            let index = this._findCell(target);\n            if (index === -1) {\n                index = this.widgets.length;\n            }\n            const start = index;\n            const values = event.mimeData.getData(JUPYTER_CELL_MIME);\n            const factory = model.contentFactory;\n            // Insert the copies of the original cells.\n            model.cells.beginCompoundOperation();\n            each(values, (cell) => {\n                let value;\n                switch (cell.cell_type) {\n                    case 'code':\n                        value = factory.createCodeCell({ cell });\n                        break;\n                    case 'markdown':\n                        value = factory.createMarkdownCell({ cell });\n                        break;\n                    default:\n                        value = factory.createRawCell({ cell });\n                        break;\n                }\n                model.cells.insert(index++, value);\n            });\n            model.cells.endCompoundOperation();\n            // Select the inserted cells.\n            this.deselectAll();\n            this.activeCellIndex = start;\n            this.extendContiguousSelectionTo(index - 1);\n        }\n    }\n    /**\n     * Start a drag event.\n     */\n    _startDrag(index, clientX, clientY) {\n        var _a;\n        const cells = this.model.cells;\n        const selected = [];\n        const toMove = [];\n        each(this.widgets, (widget, i) => {\n            const cell = cells.get(i);\n            if (this.isSelectedOrActive(widget)) {\n                widget.addClass(DROP_SOURCE_CLASS);\n                selected.push(cell.toJSON());\n                toMove.push(widget);\n            }\n        });\n        const activeCell = this.activeCell;\n        let dragImage = null;\n        let countString;\n        if ((activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.type) === 'code') {\n            const executionCount = activeCell.model\n                .executionCount;\n            countString = ' ';\n            if (executionCount) {\n                countString = executionCount.toString();\n            }\n        }\n        else {\n            countString = '';\n        }\n        // Create the drag image.\n        dragImage = Private.createDragImage(selected.length, countString, (_a = activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.value.text.split('\\n')[0].slice(0, 26)) !== null && _a !== void 0 ? _a : '');\n        // Set up the drag event.\n        this._drag = new Drag({\n            mimeData: new MimeData(),\n            dragImage,\n            supportedActions: 'copy-move',\n            proposedAction: 'copy',\n            source: this\n        });\n        this._drag.mimeData.setData(JUPYTER_CELL_MIME, selected);\n        // Add mimeData for the fully reified cell widgets, for the\n        // case where the target is in the same notebook and we\n        // can just move the cells.\n        this._drag.mimeData.setData('internal:cells', toMove);\n        // Add mimeData for the text content of the selected cells,\n        // allowing for drag/drop into plain text fields.\n        const textContent = toMove.map(cell => cell.model.value.text).join('\\n');\n        this._drag.mimeData.setData('text/plain', textContent);\n        // Remove mousemove and mouseup listeners and start the drag.\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        this._mouseMode = null;\n        void this._drag.start(clientX, clientY).then(action => {\n            if (this.isDisposed) {\n                return;\n            }\n            this._drag = null;\n            each(toMove, widget => {\n                widget.removeClass(DROP_SOURCE_CLASS);\n            });\n        });\n    }\n    /**\n     * Handle `focus` events for the widget.\n     */\n    _evtFocusIn(event) {\n        const target = event.target;\n        const index = this._findCell(target);\n        if (index !== -1) {\n            const widget = this.widgets[index];\n            // If the editor itself does not have focus, ensure command mode.\n            if (!widget.editorWidget.node.contains(target)) {\n                this.mode = 'command';\n            }\n            this.activeCellIndex = index;\n            // If the editor has focus, ensure edit mode.\n            const node = widget.editorWidget.node;\n            if (node.contains(target)) {\n                this.mode = 'edit';\n            }\n        }\n        else {\n            // No cell has focus, ensure command mode.\n            this.mode = 'command';\n        }\n        if (this.mode === 'command' && target !== this.node) {\n            delete this.node.dataset[CODE_RUNNER];\n        }\n        else {\n            this.node.dataset[CODE_RUNNER] = 'true';\n        }\n    }\n    /**\n     * Handle `focusout` events for the notebook.\n     */\n    _evtFocusOut(event) {\n        const relatedTarget = event.relatedTarget;\n        // Bail if the window is losing focus, to preserve edit mode. This test\n        // assumes that we explicitly focus things rather than calling blur()\n        if (!relatedTarget) {\n            return;\n        }\n        // Bail if the item gaining focus is another cell,\n        // and we should not be entering command mode.\n        const index = this._findCell(relatedTarget);\n        if (index !== -1) {\n            const widget = this.widgets[index];\n            if (widget.editorWidget.node.contains(relatedTarget)) {\n                return;\n            }\n        }\n        // Otherwise enter command mode if not already.\n        if (this.mode !== 'command') {\n            this.mode = 'command';\n            // Switching to command mode currently focuses the notebook element, so\n            // refocus the relatedTarget so the focus actually switches as intended.\n            if (relatedTarget) {\n                relatedTarget.focus();\n            }\n        }\n    }\n    /**\n     * Handle `dblclick` events for the widget.\n     */\n    _evtDblClick(event) {\n        const model = this.model;\n        if (!model) {\n            return;\n        }\n        this.deselectAll();\n        const [target, index] = this._findEventTargetAndCell(event);\n        if (index === -1) {\n            return;\n        }\n        this.activeCellIndex = index;\n        if (model.cells.get(index).type === 'markdown') {\n            const widget = this.widgets[index];\n            widget.rendered = false;\n        }\n        else if (target.localName === 'img') {\n            target.classList.toggle(UNCONFINED_CLASS);\n        }\n    }\n    /**\n     * Remove selections from inactive cells to avoid\n     * spurious cursors.\n     */\n    _trimSelections() {\n        for (let i = 0; i < this.widgets.length; i++) {\n            if (i !== this._activeCellIndex) {\n                const cell = this.widgets[i];\n                cell.model.selections.delete(cell.editor.uuid);\n            }\n        }\n    }\n}\n/**\n * The namespace for the `Notebook` class statics.\n */\n(function (Notebook) {\n    /**\n     * The default implementation of a notebook content factory..\n     *\n     * #### Notes\n     * Override methods on this class to customize the default notebook factory\n     * methods that create notebook content.\n     */\n    class ContentFactory extends StaticNotebook.ContentFactory {\n    }\n    Notebook.ContentFactory = ContentFactory;\n    Notebook.defaultContentFactory = new ContentFactory();\n})(Notebook || (Notebook = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for the selected state of a cell.\n     */\n    Private.selectedProperty = new AttachedProperty({\n        name: 'selected',\n        create: () => false\n    });\n    /**\n     * A custom panel layout for the notebook.\n     */\n    class NotebookPanelLayout extends PanelLayout {\n        /**\n         * A message handler invoked on an `'update-request'` message.\n         *\n         * #### Notes\n         * This is a reimplementation of the base class method,\n         * and is a no-op.\n         */\n        onUpdateRequest(msg) {\n            // This is a no-op.\n        }\n    }\n    Private.NotebookPanelLayout = NotebookPanelLayout;\n    /**\n     * Create a cell drag image.\n     */\n    function createDragImage(count, promptNumber, cellContent) {\n        if (count > 1) {\n            if (promptNumber !== '') {\n                return VirtualDOM.realize(h.div(h.div({ className: DRAG_IMAGE_CLASS }, h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));\n            }\n            else {\n                return VirtualDOM.realize(h.div(h.div({ className: DRAG_IMAGE_CLASS }, h.span({ className: CELL_DRAG_PROMPT_CLASS }), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));\n            }\n        }\n        else {\n            if (promptNumber !== '') {\n                return VirtualDOM.realize(h.div(h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));\n            }\n            else {\n                return VirtualDOM.realize(h.div(h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, h.span({ className: CELL_DRAG_PROMPT_CLASS }), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));\n            }\n        }\n    }\n    Private.createDragImage = createDragImage;\n    /**\n     * Process the `IOptions` passed to the notebook widget.\n     *\n     * #### Notes\n     * This defaults the content factory to that in the `Notebook` namespace.\n     */\n    function processNotebookOptions(options) {\n        if (options.contentFactory) {\n            return options;\n        }\n        else {\n            return {\n                rendermime: options.rendermime,\n                languagePreference: options.languagePreference,\n                contentFactory: Notebook.defaultContentFactory,\n                mimeTypeService: options.mimeTypeService\n            };\n        }\n    }\n    Private.processNotebookOptions = processNotebookOptions;\n})(Private || (Private = {}));\n//# sourceMappingURL=widget.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { isMarkdownCellModel } from '@jupyterlab/cells';\nimport { each } from '@lumino/algorithm';\nimport { Token } from '@lumino/coreutils';\nimport { Printing, showDialog, Dialog } from '@jupyterlab/apputils';\nimport { DocumentWidget } from '@jupyterlab/docregistry';\nimport { Notebook } from './widget';\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { nullTranslator } from '@jupyterlab/translation';\n/**\n * The class name added to notebook panels.\n */\nconst NOTEBOOK_PANEL_CLASS = 'jp-NotebookPanel';\nconst NOTEBOOK_PANEL_TOOLBAR_CLASS = 'jp-NotebookPanel-toolbar';\nconst NOTEBOOK_PANEL_NOTEBOOK_CLASS = 'jp-NotebookPanel-notebook';\n/**\n * A widget that hosts a notebook toolbar and content area.\n *\n * #### Notes\n * The widget keeps the document metadata in sync with the current\n * kernel on the context.\n */\nexport class NotebookPanel extends DocumentWidget {\n    /**\n     * Construct a new notebook panel.\n     */\n    constructor(options) {\n        super(options);\n        /**\n         * Whether we are currently in a series of autorestarts we have already\n         * notified the user about.\n         */\n        this._autorestarting = false;\n        this.translator = options.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        // Set up CSS classes\n        this.addClass(NOTEBOOK_PANEL_CLASS);\n        this.toolbar.addClass(NOTEBOOK_PANEL_TOOLBAR_CLASS);\n        this.content.addClass(NOTEBOOK_PANEL_NOTEBOOK_CLASS);\n        // Set up things related to the context\n        this.content.model = this.context.model;\n        this.context.sessionContext.kernelChanged.connect(this._onKernelChanged, this);\n        this.context.sessionContext.statusChanged.connect(this._onSessionStatusChanged, this);\n        this.context.saveState.connect(this._onSave, this);\n        void this.revealed.then(() => {\n            if (this.isDisposed) {\n                // this widget has already been disposed, bail\n                return;\n            }\n            // Set the document edit mode on initial open if it looks like a new document.\n            if (this.content.widgets.length === 1) {\n                const cellModel = this.content.widgets[0].model;\n                if (cellModel.type === 'code' && cellModel.value.text === '') {\n                    this.content.mode = 'edit';\n                }\n            }\n        });\n    }\n    _onSave(sender, state) {\n        if (state === 'started' && this.model) {\n            // Find markdown cells\n            const { cells } = this.model;\n            each(cells, cell => {\n                if (isMarkdownCellModel(cell)) {\n                    for (const key of cell.attachments.keys) {\n                        if (!cell.value.text.includes(key)) {\n                            cell.attachments.remove(key);\n                        }\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * The session context used by the panel.\n     */\n    get sessionContext() {\n        return this.context.sessionContext;\n    }\n    /**\n     * The model for the widget.\n     */\n    get model() {\n        return this.content.model;\n    }\n    /**\n     * Update the options for the current notebook panel.\n     *\n     * @param config new options to set\n     */\n    setConfig(config) {\n        this.content.editorConfig = config.editorConfig;\n        this.content.notebookConfig = config.notebookConfig;\n        // Update kernel shutdown behavior\n        const kernelPreference = this.context.sessionContext.kernelPreference;\n        this.context.sessionContext.kernelPreference = Object.assign(Object.assign({}, kernelPreference), { shutdownOnDispose: config.kernelShutdown });\n    }\n    /**\n     * Set URI fragment identifier.\n     */\n    setFragment(fragment) {\n        void this.context.ready.then(() => {\n            this.content.setFragment(fragment);\n        });\n    }\n    /**\n     * Dispose of the resources used by the widget.\n     */\n    dispose() {\n        this.content.dispose();\n        super.dispose();\n    }\n    /**\n     * Prints the notebook by converting to HTML with nbconvert.\n     */\n    [Printing.symbol]() {\n        return async () => {\n            // Save before generating HTML\n            if (this.context.model.dirty && !this.context.model.readOnly) {\n                await this.context.save();\n            }\n            await Printing.printURL(PageConfig.getNBConvertURL({\n                format: 'html',\n                download: false,\n                path: this.context.path\n            }));\n        };\n    }\n    /**\n     * Handle a change in the kernel by updating the document metadata.\n     */\n    _onKernelChanged(sender, args) {\n        if (!this.model || !args.newValue) {\n            return;\n        }\n        const { newValue } = args;\n        void newValue.info.then(info => {\n            var _a;\n            if (this.model &&\n                ((_a = this.context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) === newValue) {\n                this._updateLanguage(info.language_info);\n            }\n        });\n        void this._updateSpec(newValue);\n    }\n    _onSessionStatusChanged(sender, status) {\n        var _a;\n        // If the status is autorestarting, and we aren't already in a series of\n        // autorestarts, show the dialog.\n        if (status === 'autorestarting' && !this._autorestarting) {\n            // The kernel died and the server is restarting it. We notify the user so\n            // they know why their kernel state is gone.\n            void showDialog({\n                title: this._trans.__('Kernel Restarting'),\n                body: this._trans.__('The kernel for %1 appears to have died. It will restart automatically.', (_a = this.sessionContext.session) === null || _a === void 0 ? void 0 : _a.path),\n                buttons: [Dialog.okButton({ label: this._trans.__('Ok') })]\n            });\n            this._autorestarting = true;\n        }\n        else if (status === 'restarting') {\n            // Another autorestart attempt will first change the status to\n            // restarting, then to autorestarting again, so we don't reset the\n            // autorestarting status if the status is 'restarting'.\n            /* no-op */\n        }\n        else {\n            this._autorestarting = false;\n        }\n    }\n    /**\n     * Update the kernel language.\n     */\n    _updateLanguage(language) {\n        this.model.metadata.set('language_info', language);\n    }\n    /**\n     * Update the kernel spec.\n     */\n    async _updateSpec(kernel) {\n        const spec = await kernel.spec;\n        if (this.isDisposed) {\n            return;\n        }\n        this.model.metadata.set('kernelspec', {\n            name: kernel.name,\n            display_name: spec === null || spec === void 0 ? void 0 : spec.display_name,\n            language: spec === null || spec === void 0 ? void 0 : spec.language\n        });\n    }\n}\n/**\n * A namespace for `NotebookPanel` statics.\n */\n(function (NotebookPanel) {\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory extends Notebook.ContentFactory {\n        /**\n         * Create a new content area for the panel.\n         */\n        createNotebook(options) {\n            return new Notebook(options);\n        }\n    }\n    NotebookPanel.ContentFactory = ContentFactory;\n    /**\n     * Default content factory for the notebook panel.\n     */\n    NotebookPanel.defaultContentFactory = new ContentFactory();\n    /* tslint:disable */\n    /**\n     * The notebook renderer token.\n     */\n    NotebookPanel.IContentFactory = new Token('@jupyterlab/notebook:IContentFactory');\n    /* tslint:enable */\n})(NotebookPanel || (NotebookPanel = {}));\n//# sourceMappingURL=panel.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { WidgetTracker } from '@jupyterlab/apputils';\nimport { Signal } from '@lumino/signaling';\nexport class NotebookTracker extends WidgetTracker {\n    constructor() {\n        super(...arguments);\n        this._activeCell = null;\n        this._activeCellChanged = new Signal(this);\n        this._selectionChanged = new Signal(this);\n    }\n    /**\n     * The currently focused cell.\n     *\n     * #### Notes\n     * This is a read-only property. If there is no cell with the focus, then this\n     * value is `null`.\n     */\n    get activeCell() {\n        const widget = this.currentWidget;\n        if (!widget) {\n            return null;\n        }\n        return widget.content.activeCell || null;\n    }\n    /**\n     * A signal emitted when the current active cell changes.\n     *\n     * #### Notes\n     * If there is no cell with the focus, then `null` will be emitted.\n     */\n    get activeCellChanged() {\n        return this._activeCellChanged;\n    }\n    /**\n     * A signal emitted when the selection state changes.\n     */\n    get selectionChanged() {\n        return this._selectionChanged;\n    }\n    /**\n     * Add a new notebook panel to the tracker.\n     *\n     * @param panel - The notebook panel being added.\n     */\n    add(panel) {\n        const promise = super.add(panel);\n        panel.content.activeCellChanged.connect(this._onActiveCellChanged, this);\n        panel.content.selectionChanged.connect(this._onSelectionChanged, this);\n        return promise;\n    }\n    /**\n     * Dispose of the resources held by the tracker.\n     */\n    dispose() {\n        this._activeCell = null;\n        super.dispose();\n    }\n    /**\n     * Handle the current change event.\n     */\n    onCurrentChanged(widget) {\n        // Store an internal reference to active cell to prevent false positives.\n        const activeCell = this.activeCell;\n        if (activeCell && activeCell === this._activeCell) {\n            return;\n        }\n        this._activeCell = activeCell;\n        if (!widget) {\n            return;\n        }\n        // Since the notebook has changed, immediately signal an active cell change\n        this._activeCellChanged.emit(widget.content.activeCell || null);\n    }\n    _onActiveCellChanged(sender, cell) {\n        // Check if the active cell change happened for the current notebook.\n        if (this.currentWidget && this.currentWidget.content === sender) {\n            this._activeCell = cell || null;\n            this._activeCellChanged.emit(this._activeCell);\n        }\n    }\n    _onSelectionChanged(sender) {\n        // Check if the selection change happened for the current notebook.\n        if (this.currentWidget && this.currentWidget.content === sender) {\n            this._selectionChanged.emit(void 0);\n        }\n    }\n}\n//# sourceMappingURL=tracker.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ABCWidgetFactory } from '@jupyterlab/docregistry';\nimport { ToolbarItems } from './default-toolbar';\nimport { NotebookPanel } from './panel';\nimport { StaticNotebook } from './widget';\nimport { sessionContextDialogs } from '@jupyterlab/apputils';\n/**\n * A widget factory for notebook panels.\n */\nexport class NotebookWidgetFactory extends ABCWidgetFactory {\n    /**\n     * Construct a new notebook widget factory.\n     *\n     * @param options - The options used to construct the factory.\n     */\n    constructor(options) {\n        super(options);\n        this.rendermime = options.rendermime;\n        this.contentFactory =\n            options.contentFactory || NotebookPanel.defaultContentFactory;\n        this.mimeTypeService = options.mimeTypeService;\n        this._editorConfig =\n            options.editorConfig || StaticNotebook.defaultEditorConfig;\n        this._notebookConfig =\n            options.notebookConfig || StaticNotebook.defaultNotebookConfig;\n        this._sessionDialogs = options.sessionDialogs || sessionContextDialogs;\n    }\n    /**\n     * A configuration object for cell editor settings.\n     */\n    get editorConfig() {\n        return this._editorConfig;\n    }\n    set editorConfig(value) {\n        this._editorConfig = value;\n    }\n    /**\n     * A configuration object for notebook settings.\n     */\n    get notebookConfig() {\n        return this._notebookConfig;\n    }\n    set notebookConfig(value) {\n        this._notebookConfig = value;\n    }\n    /**\n     * Create a new widget.\n     *\n     * #### Notes\n     * The factory will start the appropriate kernel.\n     */\n    createNewWidget(context, source) {\n        const nbOptions = {\n            rendermime: source\n                ? source.content.rendermime\n                : this.rendermime.clone({ resolver: context.urlResolver }),\n            contentFactory: this.contentFactory,\n            mimeTypeService: this.mimeTypeService,\n            editorConfig: source ? source.content.editorConfig : this._editorConfig,\n            notebookConfig: source\n                ? source.content.notebookConfig\n                : this._notebookConfig\n        };\n        const content = this.contentFactory.createNotebook(nbOptions);\n        return new NotebookPanel({ context, content });\n    }\n    /**\n     * Default factory for toolbar items to be added after the widget is created.\n     */\n    defaultToolbarFactory(widget) {\n        return ToolbarItems.getDefaultItems(widget, this._sessionDialogs, this.translator);\n    }\n}\n//# sourceMappingURL=widgetfactory.js.map","import * as React from 'react';\nimport { VDomRenderer, VDomModel } from '@jupyterlab/apputils';\nimport { Text } from '@jupyterlab/coreutils';\nimport { TextItem } from '@jupyterlab/statusbar';\nimport { nullTranslator } from '@jupyterlab/translation';\n/**\n * A pure function for rendering a Command/Edit mode component.\n *\n * @param props: the props for rendering the component.\n *\n * @returns a tsx component for command/edit mode.\n */\nfunction CommandEditComponent(props) {\n    const trans = (props.translator || nullTranslator).load('jupyterlab');\n    return (React.createElement(TextItem, { source: trans.__('Mode: %1', Text.titleCase(props.notebookMode)) }));\n}\n/**\n * StatusBar item to display which notebook mode user is in.\n */\nexport class CommandEditStatus extends VDomRenderer {\n    /**\n     * Construct a new CommandEdit status item.\n     */\n    constructor(translator) {\n        super(new CommandEditStatus.Model());\n        this.translator = translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n    }\n    /**\n     * Render the CommandEdit status item.\n     */\n    render() {\n        if (!this.model) {\n            return null;\n        }\n        this.node.title = this._trans.__('Notebook is in %1 mode', this.model.notebookMode);\n        return (React.createElement(CommandEditComponent, { notebookMode: this.model.notebookMode, translator: this.translator }));\n    }\n}\n/**\n * A namespace for CommandEdit statics.\n */\n(function (CommandEditStatus) {\n    /**\n     * A VDomModle for the CommandEdit renderer.\n     */\n    class Model extends VDomModel {\n        constructor() {\n            super(...arguments);\n            /**\n             * On a change to the notebook, update the mode.\n             */\n            this._onChanged = (_notebook) => {\n                const oldMode = this._notebookMode;\n                if (this._notebook) {\n                    this._notebookMode = _notebook.mode;\n                }\n                else {\n                    this._notebookMode = 'command';\n                }\n                this._triggerChange(oldMode, this._notebookMode);\n            };\n            this._notebookMode = 'command';\n            this._notebook = null;\n        }\n        /**\n         * The current mode of the current notebook.\n         */\n        get notebookMode() {\n            return this._notebookMode;\n        }\n        /**\n         * Set the current notebook for the model.\n         */\n        set notebook(notebook) {\n            const oldNotebook = this._notebook;\n            if (oldNotebook !== null) {\n                oldNotebook.stateChanged.disconnect(this._onChanged, this);\n                oldNotebook.activeCellChanged.disconnect(this._onChanged, this);\n                oldNotebook.modelContentChanged.disconnect(this._onChanged, this);\n            }\n            const oldMode = this._notebookMode;\n            this._notebook = notebook;\n            if (this._notebook === null) {\n                this._notebookMode = 'command';\n            }\n            else {\n                this._notebookMode = this._notebook.mode;\n                this._notebook.stateChanged.connect(this._onChanged, this);\n                this._notebook.activeCellChanged.connect(this._onChanged, this);\n                this._notebook.modelContentChanged.connect(this._onChanged, this);\n            }\n            this._triggerChange(oldMode, this._notebookMode);\n        }\n        /**\n         * Trigger a state change for the renderer.\n         */\n        _triggerChange(oldState, newState) {\n            if (oldState !== newState) {\n                this.stateChanged.emit(void 0);\n            }\n        }\n    }\n    CommandEditStatus.Model = Model;\n})(CommandEditStatus || (CommandEditStatus = {}));\n//# sourceMappingURL=modestatus.js.map","import React from 'react';\nimport { VDomRenderer, VDomModel } from '@jupyterlab/apputils';\nimport { notTrustedIcon, trustedIcon } from '@jupyterlab/ui-components';\nimport { toArray } from '@lumino/algorithm';\nimport { nullTranslator } from '@jupyterlab/translation';\n/**\n * Determine the notebook trust status message.\n */\nfunction cellTrust(props, translator) {\n    translator = translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    if (props.trustedCells === props.totalCells) {\n        return [\n            trans.__('Notebook trusted: %1 of %2 cells trusted.', props.trustedCells, props.totalCells),\n            'jp-StatusItem-trusted'\n        ];\n    }\n    else if (props.activeCellTrusted) {\n        return [\n            trans.__('Active cell trusted: %1 of %2 cells trusted.', props.trustedCells, props.totalCells),\n            'jp-StatusItem-trusted'\n        ];\n    }\n    else {\n        return [\n            trans.__('Notebook not trusted: %1 of %2 cells trusted.', props.trustedCells, props.totalCells),\n            'jp-StatusItem-untrusted'\n        ];\n    }\n}\n/**\n * A pure function for a notebook trust status component.\n *\n * @param props: the props for the component.\n *\n * @returns a tsx component for notebook trust.\n */\nfunction NotebookTrustComponent(props) {\n    if (props.allCellsTrusted) {\n        return React.createElement(trustedIcon.react, { top: '2px', stylesheet: 'statusBar' });\n    }\n    else {\n        return React.createElement(notTrustedIcon.react, { top: '2px', stylesheet: 'statusBar' });\n    }\n}\n/**\n * The NotebookTrust status item.\n */\nexport class NotebookTrustStatus extends VDomRenderer {\n    /**\n     * Construct a new status item.\n     */\n    constructor(translator) {\n        super(new NotebookTrustStatus.Model());\n        this.translator = translator || nullTranslator;\n    }\n    /**\n     * Render the NotebookTrust status item.\n     */\n    render() {\n        if (!this.model) {\n            return null;\n        }\n        this.node.title = cellTrust(this.model, this.translator)[0];\n        return (React.createElement(\"div\", null,\n            React.createElement(NotebookTrustComponent, { allCellsTrusted: this.model.trustedCells === this.model.totalCells, activeCellTrusted: this.model.activeCellTrusted, totalCells: this.model.totalCells, trustedCells: this.model.trustedCells })));\n    }\n}\n/**\n * A namespace for NotebookTrust statics.\n */\n(function (NotebookTrustStatus) {\n    /**\n     * A VDomModel for the NotebookTrust status item.\n     */\n    class Model extends VDomModel {\n        constructor() {\n            super(...arguments);\n            this._trustedCells = 0;\n            this._totalCells = 0;\n            this._activeCellTrusted = false;\n            this._notebook = null;\n        }\n        /**\n         * The number of trusted cells in the current notebook.\n         */\n        get trustedCells() {\n            return this._trustedCells;\n        }\n        /**\n         * The total number of cells in the current notebook.\n         */\n        get totalCells() {\n            return this._totalCells;\n        }\n        /**\n         * Whether the active cell is trusted.\n         */\n        get activeCellTrusted() {\n            return this._activeCellTrusted;\n        }\n        /**\n         * The current notebook for the model.\n         */\n        get notebook() {\n            return this._notebook;\n        }\n        set notebook(model) {\n            const oldNotebook = this._notebook;\n            if (oldNotebook !== null) {\n                oldNotebook.activeCellChanged.disconnect(this._onActiveCellChanged, this);\n                oldNotebook.modelContentChanged.disconnect(this._onModelChanged, this);\n            }\n            const oldState = this._getAllState();\n            this._notebook = model;\n            if (this._notebook === null) {\n                this._trustedCells = 0;\n                this._totalCells = 0;\n                this._activeCellTrusted = false;\n            }\n            else {\n                // Add listeners\n                this._notebook.activeCellChanged.connect(this._onActiveCellChanged, this);\n                this._notebook.modelContentChanged.connect(this._onModelChanged, this);\n                // Derive values\n                if (this._notebook.activeCell !== undefined) {\n                    this._activeCellTrusted = this._notebook.activeCell.model.trusted;\n                }\n                else {\n                    this._activeCellTrusted = false;\n                }\n                const { total, trusted } = this._deriveCellTrustState(this._notebook.model);\n                this._totalCells = total;\n                this._trustedCells = trusted;\n            }\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * When the notebook model changes, update the trust state.\n         */\n        _onModelChanged(notebook) {\n            const oldState = this._getAllState();\n            const { total, trusted } = this._deriveCellTrustState(notebook.model);\n            this._totalCells = total;\n            this._trustedCells = trusted;\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * When the active cell changes, update the trust state.\n         */\n        _onActiveCellChanged(model, cell) {\n            const oldState = this._getAllState();\n            if (cell) {\n                this._activeCellTrusted = cell.model.trusted;\n            }\n            else {\n                this._activeCellTrusted = false;\n            }\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * Given a notebook model, figure out how many of the cells are trusted.\n         */\n        _deriveCellTrustState(model) {\n            if (model === null) {\n                return { total: 0, trusted: 0 };\n            }\n            const cells = toArray(model.cells);\n            const trusted = cells.reduce((accum, current) => {\n                if (current.trusted) {\n                    return accum + 1;\n                }\n                else {\n                    return accum;\n                }\n            }, 0);\n            const total = cells.length;\n            return {\n                total,\n                trusted\n            };\n        }\n        /**\n         * Get the current state of the model.\n         */\n        _getAllState() {\n            return [this._trustedCells, this._totalCells, this.activeCellTrusted];\n        }\n        /**\n         * Trigger a change in the renderer.\n         */\n        _triggerChange(oldState, newState) {\n            if (oldState[0] !== newState[0] ||\n                oldState[1] !== newState[1] ||\n                oldState[2] !== newState[2]) {\n                this.stateChanged.emit(void 0);\n            }\n        }\n    }\n    NotebookTrustStatus.Model = Model;\n})(NotebookTrustStatus || (NotebookTrustStatus = {}));\n//# sourceMappingURL=truststatus.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The notebook widget factory token.\n */\nexport const INotebookWidgetFactory = new Token('@jupyterlab/notebook:INotebookWidgetFactory');\n/* tslint:enable */\n/* tslint:disable */\n/**\n * The notebook tools token.\n */\nexport const INotebookTools = new Token('@jupyterlab/notebook:INotebookTools');\n/* tslint:disable */\n/**\n * The notebook tracker token.\n */\nexport const INotebookTracker = new Token('@jupyterlab/notebook:INotebookTracker');\n//# sourceMappingURL=tokens.js.map"],"sourceRoot":""}
{"version":3,"sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/attachments/lib/model.js"],"names":["AttachmentsModel","options","this","_map","ObservableMap","_isDisposed","_stateChanged","Signal","_changed","_modelDB","_serialized","_changeGuard","contentFactory","defaultContentFactory","values","key","Object","keys","undefined","set","changed","connect","_onMapChanged","modelDB","createValue","get","fromJSON","toJSON","_onSerializedChanged","length","isDisposed","dispose","has","value","item","_createItem","delete","forEach","clear","ret","createAttachmentModel","_onGenericChange","sender","args","emit","newValue","ContentFactory","AttachmentModel","AttachmentsResolver","_parent","parent","_model","model","url","startsWith","resolveUrl","path","getDownloadUrl","slice","attachment","data","mimeType","imageRendererFactory","Error","_a","_b","_c","isLocal","call"],"mappings":"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","file":"3359.bundle.js","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ObservableMap } from '@jupyterlab/observables';\nimport { AttachmentModel, imageRendererFactory } from '@jupyterlab/rendermime';\nimport { Signal } from '@lumino/signaling';\n/**\n * The default implementation of the IAttachmentsModel.\n */\nexport class AttachmentsModel {\n    /**\n     * Construct a new observable outputs instance.\n     */\n    constructor(options = {}) {\n        this._map = new ObservableMap();\n        this._isDisposed = false;\n        this._stateChanged = new Signal(this);\n        this._changed = new Signal(this);\n        this._modelDB = null;\n        this._serialized = null;\n        this._changeGuard = false;\n        this.contentFactory =\n            options.contentFactory || AttachmentsModel.defaultContentFactory;\n        if (options.values) {\n            for (const key of Object.keys(options.values)) {\n                if (options.values[key] !== undefined) {\n                    this.set(key, options.values[key]);\n                }\n            }\n        }\n        this._map.changed.connect(this._onMapChanged, this);\n        // If we are given a IModelDB, keep an up-to-date\n        // serialized copy of the AttachmentsModel in it.\n        if (options.modelDB) {\n            this._modelDB = options.modelDB;\n            this._serialized = this._modelDB.createValue('attachments');\n            if (this._serialized.get()) {\n                this.fromJSON(this._serialized.get());\n            }\n            else {\n                this._serialized.set(this.toJSON());\n            }\n            this._serialized.changed.connect(this._onSerializedChanged, this);\n        }\n    }\n    /**\n     * A signal emitted when the model state changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * A signal emitted when the model changes.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * The keys of the attachments in the model.\n     */\n    get keys() {\n        return this._map.keys();\n    }\n    /**\n     * Get the length of the items in the model.\n     */\n    get length() {\n        return this._map.keys().length;\n    }\n    /**\n     * Test whether the model is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources used by the model.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._map.dispose();\n        Signal.clearData(this);\n    }\n    /**\n     * Whether the specified key is set.\n     */\n    has(key) {\n        return this._map.has(key);\n    }\n    /**\n     * Get an item at the specified key.\n     */\n    get(key) {\n        return this._map.get(key);\n    }\n    /**\n     * Set the value at the specified key.\n     */\n    set(key, value) {\n        // Normalize stream data.\n        const item = this._createItem({ value });\n        this._map.set(key, item);\n    }\n    /**\n     * Remove the attachment whose name is the specified key\n     */\n    remove(key) {\n        this._map.delete(key);\n    }\n    /**\n     * Clear all of the attachments.\n     */\n    clear() {\n        this._map.values().forEach((item) => {\n            item.dispose();\n        });\n        this._map.clear();\n    }\n    /**\n     * Deserialize the model from JSON.\n     *\n     * #### Notes\n     * This will clear any existing data.\n     */\n    fromJSON(values) {\n        this.clear();\n        Object.keys(values).forEach(key => {\n            if (values[key] !== undefined) {\n                this.set(key, values[key]);\n            }\n        });\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        const ret = {};\n        for (const key of this._map.keys()) {\n            ret[key] = this._map.get(key).toJSON();\n        }\n        return ret;\n    }\n    /**\n     * Create an attachment item and hook up its signals.\n     */\n    _createItem(options) {\n        const factory = this.contentFactory;\n        const item = factory.createAttachmentModel(options);\n        item.changed.connect(this._onGenericChange, this);\n        return item;\n    }\n    /**\n     * Handle a change to the list.\n     */\n    _onMapChanged(sender, args) {\n        if (this._serialized && !this._changeGuard) {\n            this._changeGuard = true;\n            this._serialized.set(this.toJSON());\n            this._changeGuard = false;\n        }\n        this._changed.emit(args);\n        this._stateChanged.emit(void 0);\n    }\n    /**\n     * If the serialized version of the outputs have changed due to a remote\n     * action, then update the model accordingly.\n     */\n    _onSerializedChanged(sender, args) {\n        if (!this._changeGuard) {\n            this._changeGuard = true;\n            this.fromJSON(args.newValue);\n            this._changeGuard = false;\n        }\n    }\n    /**\n     * Handle a change to an item.\n     */\n    _onGenericChange() {\n        this._stateChanged.emit(void 0);\n    }\n}\n/**\n * The namespace for AttachmentsModel class statics.\n */\n(function (AttachmentsModel) {\n    /**\n     * The default implementation of a `IAttachemntsModel.IContentFactory`.\n     */\n    class ContentFactory {\n        /**\n         * Create an attachment model.\n         */\n        createAttachmentModel(options) {\n            return new AttachmentModel(options);\n        }\n    }\n    AttachmentsModel.ContentFactory = ContentFactory;\n    /**\n     * The default attachment model factory.\n     */\n    AttachmentsModel.defaultContentFactory = new ContentFactory();\n})(AttachmentsModel || (AttachmentsModel = {}));\n/**\n * A resolver for cell attachments 'attchment:filename'.\n *\n * Will resolve to a data: url.\n */\nexport class AttachmentsResolver {\n    /**\n     * Create an attachments resolver object.\n     */\n    constructor(options) {\n        this._parent = options.parent || null;\n        this._model = options.model;\n    }\n    /**\n     * Resolve a relative url to a correct server path.\n     */\n    async resolveUrl(url) {\n        if (this._parent && !url.startsWith('attachment:')) {\n            return this._parent.resolveUrl(url);\n        }\n        return url;\n    }\n    /**\n     * Get the download url of a given absolute server path.\n     *\n     * #### Notes\n     * The returned URL may include a query parameter.\n     */\n    async getDownloadUrl(path) {\n        if (this._parent && !path.startsWith('attachment:')) {\n            return this._parent.getDownloadUrl(path);\n        }\n        // Return a data URL with the data of the url\n        const key = path.slice('attachment:'.length);\n        const attachment = this._model.get(key);\n        if (attachment === undefined) {\n            // Resolve with unprocessed path, to show as broken image\n            return path;\n        }\n        const { data } = attachment;\n        const mimeType = Object.keys(data)[0];\n        // Only support known safe types:\n        if (mimeType === undefined ||\n            imageRendererFactory.mimeTypes.indexOf(mimeType) === -1) {\n            throw new Error(`Cannot render unknown image mime type \"${mimeType}\".`);\n        }\n        const dataUrl = `data:${mimeType};base64,${data[mimeType]}`;\n        return dataUrl;\n    }\n    /**\n     * Whether the URL should be handled by the resolver\n     * or not.\n     */\n    isLocal(url) {\n        var _a, _b, _c;\n        if (this._parent && !url.startsWith('attachment:')) {\n            return (_c = (_b = (_a = this._parent).isLocal) === null || _b === void 0 ? void 0 : _b.call(_a, url)) !== null && _c !== void 0 ? _c : true;\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=model.js.map"],"sourceRoot":""}
(self.webpackChunk_JUPYTERLAB_CORE_OUTPUT=self.webpackChunk_JUPYTERLAB_CORE_OUTPUT||[]).push([[6035],{64831:(e,t,s)=>{"use strict";s.d(t,{L:()=>i,q:()=>r});var n=s(9727);const i=new n.Token("@jupyterlite/kernel:IKernels"),r=new n.Token("@jupyterlite/kernelspec:IKernelSpecs")},16035:(e,t,s)=>{"use strict";s.r(t),s.d(t,{default:()=>P});var n=s(9727);const i=new n.Token("@jupyterlite/contents:IContents");var r=s(82090),o=s(94269),a=s(75138),c=s(75486),l=s.n(c);const h="JupyterLite Storage";class d{constructor(){this._serverContents=new Map,this._isDisposed=!1,this._fileChanged=new a.Signal(this),this._storage=l().createInstance({name:h,description:"Offline Storage for Notebooks and Files",storeName:"files",version:1}),this._counters=l().createInstance({name:h,description:"Store the current file suffix counters",storeName:"counters",version:1}),this._checkpoints=l().createInstance({name:h,description:"Offline Storage for Checkpoints",storeName:"checkpoints",version:1})}get fileChanged(){return this._fileChanged}get isDisposed(){return this._isDisposed}get serverSettings(){return o.ServerConnection.makeSettings()}dispose(){throw new Error("Method not implemented.")}async newUntitled(e){var t,s,n;const i=null!==(t=null==e?void 0:e.path)&&void 0!==t?t:"",r=null!==(s=null==e?void 0:e.type)&&void 0!==s?s:"notebook",o=(new Date).toISOString(),a=i?`${i}/`:"";let c,l="";switch(r){case"directory":l+=`Untitled Folder${await this._incrementCounter("directory")||""}`,c={name:l,path:`${a}${l}`,last_modified:o,created:o,format:"text",mimetype:"",content:null,size:void 0,writable:!0,type:"directory"};break;case"file":{const t=null!==(n=null==e?void 0:e.ext)&&void 0!==n?n:".txt";l+=`untitled${await this._incrementCounter("file")||""}${t}`,c={name:l,path:`${a}${l}`,last_modified:o,created:o,format:"text",mimetype:"text/plain",content:"",size:0,writable:!0,type:"file"};break}default:l+=`Untitled${await this._incrementCounter("notebook")||""}.ipynb`,c={name:l,path:`${a}${l}`,last_modified:o,created:o,format:"json",mimetype:"application/json",content:p.EMPTY_NB,size:JSON.stringify(p.EMPTY_NB).length,writable:!0,type:"notebook"}}const h=`${a}${l}`;return await this._storage.setItem(h,c),c}async copy(e,t){let s=r.PathExt.basename(e);for(t=""===t?"":`${t.slice(1)}/`;await this._storage.getItem(`${t}${s}`);){const e=r.PathExt.extname(s),t=s.replace(e,"");s=`${t} (copy)${e}`}const n=`${t}${s}`;let i=await this._storage.getItem(e);return i={...i,name:s,path:n},await this._storage.setItem(n,i),i}async get(e,t){if(""===(e=decodeURIComponent(e.replace(/^\//,""))))return await this.getFolder(e);const s=await this._storage.getItem(e),n=await this.getServerContents(e,t),i=s||n;if(!i)throw Error(`Could not find file with path ${e}`);if(!(null==t?void 0:t.content))return{...i,content:null,size:void 0};if("directory"===i.type){const t=new Map;await this._storage.iterate(((s,n)=>{const i=s;n===`${e}/${i.name}`&&t.set(i.name,i)}));const s=n?n.content:Array.from((await this.getServerDirectory(e)).values());for(const e of s)t.has(e.name)||t.set(e.name,e);const o=[...t.values()];return{name:r.PathExt.basename(e),path:e,last_modified:i.last_modified,created:i.created,format:"json",mimetype:"application/json",content:o,size:void 0,writable:!0,type:"directory"}}return i}async getFolder(e){const t=new Map;await this._storage.iterate(((e,s)=>{if(s.includes("/"))return;const n=e;t.set(n.path,n)}));for(const s of(await this.getServerDirectory(e)).values())t.has(s.path)||t.set(s.path,s);return{name:"",path:e,last_modified:new Date(0).toISOString(),created:new Date(0).toISOString(),format:"json",mimetype:"application/json",content:Array.from(t.values()),size:void 0,writable:!0,type:"directory"}}async getServerDirectory(e){const t=this._serverContents.get(e)||new Map;if(!this._serverContents.has(e)){const s=r.URLExt.join(r.PageConfig.getBaseUrl(),"api/contents",e,"all.json");try{const e=await fetch(s),n=JSON.parse(await e.text());for(const e of n.content)t.set(e.name,e)}catch(e){console.warn(`don't worry, about ${e}... nothing's broken. if there had been a\n          file at ${s}, you might see some more files.`)}this._serverContents.set(e,t)}return t}async getServerContents(e,t){const s=r.PathExt.basename(e);let n=(await this.getServerDirectory(r.URLExt.join(e,".."))).get(s)||{name:s,path:e,last_modified:new Date(0).toISOString(),created:new Date(0).toISOString(),format:"text",mimetype:"text/plain",type:"file",writable:!0,content:null};if(null==t?void 0:t.content)if("directory"===n.type){const t=await this.getServerDirectory(e);n={...n,content:Array.from(t.values())}}else{const t=r.URLExt.join(r.PageConfig.getBaseUrl(),"files",e),s=await fetch(t);if(!s.ok)return null;const i=n.mimetype||s.headers.get("Content-Type");n="notebook"===n.type||-1!==(null==i?void 0:i.indexOf("json"))||e.match(/\.(ipynb|[^/]*json[^/]*)$/)?{...n,content:await s.json(),format:"json",mimetype:n.mimetype||"application/json"}:"image/svg+xml"===i||-1!==i.indexOf("text")?{...n,content:await s.text(),format:"text",mimetype:i||"text/plain"}:{...n,content:btoa(String.fromCharCode(...new Uint8Array(await s.arrayBuffer()))),format:"base64",mimetype:i||"octet/stream"}}return n}async rename(e,t){const s=decodeURIComponent(e),n=await this._storage.getItem(s);if(!n)throw Error(`Could not find file with path ${s}`);const i=n,o=(new Date).toISOString(),a={...i,name:r.PathExt.basename(t),path:t,last_modified:o};return await this._storage.setItem(t,a),await this._storage.removeItem(s),await this._checkpoints.removeItem(s),a}async save(e,t={}){var s;let n=await this.get(e);n||(n=await this.newUntitled({path:e}));const i=(new Date).toISOString();n={...n,...t,last_modified:i};const o=r.PathExt.extname(null!==(s=t.name)&&void 0!==s?s:"");if(t.content&&"base64"===t.format){const e=atob(t.content),s=".ipynb"===o;n={...n,content:s?JSON.parse(e):e,format:s?"json":"text",type:s?"notebook":"file"}}return await this._storage.setItem(e,n),n}async delete(e){e=decodeURIComponent(e);const t=[];await this._storage.iterate(((s,n)=>{n.startsWith(e)&&t.push(n)})),await Promise.all(t.map((async e=>Promise.all([this._storage.removeItem(e),this._checkpoints.removeItem(e)]))))}async createCheckpoint(e){var t;const s=await this._storage.getItem(e)||await this.getServerContents(e),n=(null!==(t=await this._checkpoints.getItem(e))&&void 0!==t?t:[]).filter((e=>!!e));return n.push(s),n.length>5&&n.splice(0,n.length-5),await this._checkpoints.setItem(e,n),{id:""+(n.length-1),last_modified:s.last_modified}}async listCheckpoints(e){return(await this._checkpoints.getItem(e)||[]).filter((e=>!!e)).map(((e,t)=>({id:t.toString(),last_modified:e.last_modified})))}async restoreCheckpoint(e,t){const s=(await this._checkpoints.getItem(e)||[])[parseInt(t)];await this._storage.setItem(e,s)}async deleteCheckpoint(e,t){const s=await this._checkpoints.getItem(e)||[],n=parseInt(t);s.splice(n,1),await this._checkpoints.setItem(e,s)}addDrive(e){throw new Error("Method not implemented.")}localPath(e){throw new Error("Method not implemented.")}normalize(e){throw new Error("Method not implemented.")}resolvePath(e,t){throw new Error("Method not implemented.")}driveName(e){throw new Error("Method not implemented.")}getModelDBFactory(e){throw new Error("Method not implemented.")}getDownloadUrl(e){throw new Error("Method not implemented.")}async _incrementCounter(e){var t;const s=(null!==(t=await this._counters.getItem(e))&&void 0!==t?t:-1)+1;return await this._counters.setItem(e,s),s}}var p;!function(e){e.EMPTY_NB={metadata:{orig_nbformat:4},nbformat_minor:4,nbformat:4,cells:[]}}(p||(p={}));var u=s(62510),m=s(67411),w=s(79988),g=s(4810);class f{constructor(e){this._kernels=new u.ObservableMap,this._clients=new u.ObservableMap,this._kernelClients=new u.ObservableMap;const{kernelspecs:t}=e;this._kernelspecs=t}async startNew(e){const{id:t,name:s}=e,i=this._kernelspecs.factories.get(s);if(!i)return{id:t,name:s};const r=new g.WU,o=(e,t,s)=>{var n;const i=this._kernels.get(e);if(!i)throw Error(`No kernel ${e}`);this._clients.set(t,s),null===(n=this._kernelClients.get(e))||void 0===n||n.add(t),s.on("message",(async e=>{let t;if(e instanceof ArrayBuffer)e=new Uint8Array(e).buffer,t=(0,m.deserialize)(e);else{if("string"!=typeof e)return;t=(0,m.deserialize)(e)}(async e=>{await r.runExclusive((async()=>{await i.handleMessage(e)}))})(t)}));const o=()=>{var s;this._clients.delete(t),null===(s=this._kernelClients.get(e))||void 0===s||s.delete(t)};i.disposed.connect(o),s.onclose=o},a=null!=t?t:n.UUID.uuid4(),c=`${f.WS_BASE_URL}api/kernels/${a}/channels`,l=this._kernels.get(a);if(l)return{id:l.id,name:l.name};const h=await i({id:a,sendMessage:e=>{const t=e.header.session,s=this._clients.get(t);if(!s)return void console.warn(`Trying to send message on removed socket for kernel ${a}`);const n=(0,m.serialize)(e);if("iopub"!==e.channel)s.send(n);else{const e=this._kernelClients.get(a);null==e||e.forEach((e=>{var t;null===(t=this._clients.get(e))||void 0===t||t.send(n)}))}},name:s});await h.ready,this._kernels.set(a,h),this._kernelClients.set(a,new Set);const d=new w.Server(c);return d.on("connection",(e=>{var t;const s=null!==(t=new URL(e.url).searchParams.get("session_id"))&&void 0!==t?t:"";o(a,s,e)})),d.on("close",(()=>{this._clients.keys().forEach((e=>{var t;const s=this._clients.get(e);(null==s?void 0:s.readyState)===w.WebSocket.CLOSED&&(this._clients.delete(e),null===(t=this._kernelClients.get(a))||void 0===t||t.delete(e))}))})),h.disposed.connect((()=>{d.close(),this._kernels.delete(a),this._kernelClients.delete(a)})),{id:h.id,name:h.name}}async restart(e){const t=this._kernels.get(e);if(!t)throw Error(`Kernel ${e} does not exist`);const{id:s,name:n}=t;return t.dispose(),this.startNew({id:s,name:n})}async shutdown(e){var t;null===(t=this._kernels.delete(e))||void 0===t||t.dispose()}}!function(e){e.WS_BASE_URL=r.PageConfig.getBaseUrl().replace(/^http/,"ws")}(f||(f={}));class _{constructor(e){this._specs=new Map,this._factories=new Map}get specs(){return 0===this._specs.size?null:{default:"python",kernelspecs:Object.fromEntries(this._specs)}}get factories(){return this._factories}register(e){const{spec:t,create:s}=e;this._specs.set(t.name,t),this._factories.set(t.name,s)}}var y=s(64831);class v{constructor(){this._routes=[]}get(e,t){this._add("GET",e,t)}put(e,t){this._add("PUT",e,t)}post(e,t){this._add("POST",e,t)}patch(e,t){this._add("PATCH",e,t)}delete(e,t){this._add("DELETE",e,t)}async route(e){const t=new URL(e.url),{method:s}=e,{pathname:n}=t;for(const i of this._routes){if(i.method!==s)continue;const r=n.match(i.pattern);if(!r)continue;const o=r.slice(1);let a;if("PATCH"===i.method||"PUT"===i.method||"POST"===i.method)try{a=JSON.parse(await e.text())}catch{a=void 0}return i.callback.call(null,{pathname:n,body:a,query:Object.fromEntries(t.searchParams)},...o)}throw new Error("Cannot route "+e.method+" "+e.url)}_add(e,t,s){"string"==typeof t&&(t=new RegExp(t)),this._routes.push({method:e,pattern:t,callback:s})}}class k{constructor(e){this._router=new v;const{contents:t,kernels:s,kernelspecs:n,sessions:i,settings:r}=e;this._contents=t,this._kernels=s,this._kernelspecs=n,this._sessions=i,this._settings=r,this._addRoutes()}async fetch(e,t){if(!(e instanceof Request))throw Error("Request info is not a Request");return this._router.route(e)}_addRoutes(){const e=this._router;e.get("/api/contents/(.+)/checkpoints",(async(e,t)=>{const s=await this._contents.listCheckpoints(t);return new Response(JSON.stringify(s))})),e.post("/api/contents/(.+)/checkpoints/(.*)",(async(e,t,s)=>{const n=await this._contents.restoreCheckpoint(t,s);return new Response(JSON.stringify(n),{status:204})})),e.post("/api/contents/(.+)/checkpoints",(async(e,t)=>{const s=await this._contents.createCheckpoint(t);return new Response(JSON.stringify(s),{status:201})})),e.delete("/api/contents/(.+)/checkpoints/(.*)",(async(e,t,s)=>{const n=await this._contents.deleteCheckpoint(t,s);return new Response(JSON.stringify(n),{status:204})})),e.get("/api/contents(.*)",(async(e,t)=>{var s;const n={content:"1"===(null===(s=e.query)||void 0===s?void 0:s.content)},i=await this._contents.get(t,n);return new Response(JSON.stringify(i))})),e.post("/api/contents(.*)",(async(e,t)=>{const s=e.body,n=null==s?void 0:s.copy_from;let i;return i=n?await this._contents.copy(n,t):await this._contents.newUntitled(s),new Response(JSON.stringify(i),{status:201})})),e.patch("/api/contents(.*)",(async(e,t)=>{var s,n;const i=null!==(n=null===(s=e.body)||void 0===s?void 0:s.path)&&void 0!==n?n:"";t="/"===t[0]?t.slice(1):t;const r=await this._contents.rename(t,i);return new Response(JSON.stringify(r))})),e.put("/api/contents/(.+)",(async(e,t)=>{const s=e.body,n=await this._contents.save(t,s);return new Response(JSON.stringify(n))})),e.delete("/api/contents/(.+)",(async(e,t)=>(await this._contents.delete(t),new Response(null,{status:204})))),e.post("/api/kernels/(.*)/restart",(async(e,t)=>{const s=await this._kernels.restart(t);return new Response(JSON.stringify(s))})),e.delete("/api/kernels/(.*)",(async(e,t)=>{const s=await this._kernels.shutdown(t);return new Response(JSON.stringify(s),{status:204})})),e.get("/api/kernelspecs",(async e=>{const t=this._kernelspecs.specs;return new Response(JSON.stringify(t))})),e.get("/api/nbconvert",(async e=>new Response(JSON.stringify({})))),e.get("/api/sessions/(.+)",(async(e,t)=>{const s=await this._sessions.get(t);return new Response(JSON.stringify(s),{status:200})})),e.get("/api/sessions",(async e=>{const t=await this._sessions.list();return new Response(JSON.stringify(t),{status:200})})),e.patch("/api/sessions(.*)",(async(e,t)=>{const s=e.body,n=await this._sessions.patch(s);return new Response(JSON.stringify(n),{status:200})})),e.delete("/api/sessions/(.+)",(async(e,t)=>(await this._sessions.shutdown(t),new Response(null,{status:204})))),e.post("/api/sessions",(async e=>{const t=e.body,s=await this._sessions.startNew(t);return new Response(JSON.stringify(s),{status:201})}));const t="/api/settings/((?:@([^/]+?)[/])?([^/]+?):([^:]+))$";e.get(t,(async(e,t)=>{const s=await this._settings.get(t);return new Response(JSON.stringify(s))})),e.put(t,(async(e,t)=>{const s=e.body,{raw:n}=s;return await this._settings.save(t,n),new Response(null,{status:204})})),e.get("/api/settings",(async e=>{const t=await this._settings.getAll();return new Response(JSON.stringify(t))}))}}class S extends o.ServiceManager{constructor(e){var t;const s=e.server;super({...e,serverSettings:{...o.ServerConnection.makeSettings(),WebSocket:w.WebSocket,fetch:null!==(t=s.fetch.bind(s))&&void 0!==t?t:void 0}}),this._server=s}get server(){return this._server}}const b=new n.Token("@jupyterlite/session:ISessions");var C=s(62867);class O{constructor(e){this._sessions=[],this._kernels=e.kernels}async get(e){const t=this._sessions.find((t=>t.id===e));if(!t)throw Error(`Session ${e} not found`);return t}async list(){return this._sessions}async patch(e){const{id:t,path:s,name:n}=e,i=this._sessions.findIndex((e=>e.id===t)),r=this._sessions[i];if(!r)throw Error(`Session ${t} not found`);const o={...r,path:null!=s?s:r.path,name:null!=n?n:r.name};return this._sessions[i]=o,o}async startNew(e){var t,s,i;const{path:r,name:o}=e,a=this._sessions.find((e=>e.name===o));if(a)return a;const c=null!==(s=null===(t=e.kernel)||void 0===t?void 0:t.name)&&void 0!==s?s:"",l=null!==(i=e.id)&&void 0!==i?i:n.UUID.uuid4(),h=await this._kernels.startNew({id:l,name:c}),d={id:l,path:r,name:null!=o?o:r,type:"notebook",kernel:{id:h.id,name:h.name}};return this._sessions.push(d),d}async shutdown(e){var t;const s=this._sessions.find((t=>t.id===e));if(!s)throw Error(`Session ${e} not found`);const n=null===(t=s.kernel)||void 0===t?void 0:t.id;n&&await this._kernels.shutdown(n),C.ArrayExt.removeFirstOf(this._sessions,s)}}const E=new n.Token("@jupyterlite/settings:ISettings");var I,x=s(96111);class R{constructor(){this._storage=l().createInstance({name:"JupyterLite Storage",description:"Offline Storage for Settings",storeName:"settings",version:1})}async get(e){let t=(await this.getAll()).settings.find((t=>t.id===e));return t||(t=await this._getFederated(e)),t}async getAll(){var e;const t=null!==(e=r.PageConfig.getOption("settingsUrl"))&&void 0!==e?e:"/",s=await(await fetch(r.URLExt.join(t,"all.json"))).json();return{settings:await Promise.all(s.map((async e=>{var t;const{id:s}=e,n=null!==(t=await this._storage.getItem(s))&&void 0!==t?t:e.raw;return{...I.override(e),raw:n,settings:x.parse(n)}})))}}async save(e,t){await this._storage.setItem(e,t)}async _getFederated(e){var t;const[s,n]=e.split(":");if(!I.isFederated(s))return;const i=r.PageConfig.getOption("fullLabextensionsUrl"),o=r.URLExt.join(i,s,"schemas",s,`${n}.json`),a=r.URLExt.join(i,s,"package.json"),c=await(await fetch(o)).json(),l=await(await fetch(a)).json(),h=null!==(t=await this._storage.getItem(e))&&void 0!==t?t:"{}",d=x.parse(h)||{};return I.override({id:e,raw:h,schema:c,settings:d,version:l.version||"3.0.8"})}}!function(e){const t=JSON.parse(r.PageConfig.getOption("settingsOverrides")||"{}");e.isFederated=function(e){let t;try{t=JSON.parse(r.PageConfig.getOption("federated_extensions"))}catch{return!1}for(const{name:s}of t)if(s===e)return!0;return!1},e.override=function(e){if(t[e.id]){e.schema.properties||(e.schema.properties={});for(const[s,n]of Object.entries(t[e.id]||{}))e.schema.properties[s].default=n}return e}}(I||(I={}));const j={id:"@jupyterlite/server-extension:contents",autoStart:!0,provides:i,activate:e=>new d},N={id:"@jupyterlite/server-extension:kernels",autoStart:!0,provides:y.L,requires:[y.q],activate:(e,t)=>new f({kernelspecs:t})},U={id:"@jupyterlite/server-extension:kernelspec",autoStart:!0,provides:y.q,activate:e=>new _({})},$={id:"@jupyterlite/server-extension:sessions",autoStart:!0,provides:b,requires:[y.L],activate:(e,t)=>new O({kernels:t})},P=[j,N,U,{id:"@jupyterlite/server-extension:server",autoStart:!0,requires:[i,y.L,y.q,b,E],activate:(e,t,s,n,i,r)=>{const o=new k({contents:t,kernels:s,kernelspecs:n,sessions:i,settings:r}),a=new S({server:o});e.registerServiceManager(a)}},$,{id:"@jupyterlite/server-extension:settings",autoStart:!0,provides:E,activate:e=>new R}]}}]);
//# sourceMappingURL=6035.bundle.js.map